<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Lily's Turtles</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: #041526;
    }
    #container { width: 100%; height: 100%; }
    #container canvas { display: block; }
    #labels {
      position: fixed; inset: 0;
      pointer-events: none; z-index: 1;
    }
    .turtle-label {
      position: absolute;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-weight: bold;
      font-size: 14px;
      text-shadow: 0 1px 4px rgba(0,0,0,0.7);
      transform: translate(-50%, -100%);
      white-space: nowrap;
    }
    #title-label {
      position: absolute;
      color: white;
      font-family: 'Nunito', sans-serif;
      font-weight: 800;
      font-size: 48px;
      text-shadow: 0 0 15px rgba(255,255,255,0.5), 0 0 30px rgba(255,255,255,0.2);
      transform: translate(-50%, -100%);
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
    }
    #overlay {
      position: fixed; inset: 0;
      background: rgba(4, 21, 38, 0.92);
      display: flex; align-items: center; justify-content: center;
      z-index: 10;
    }
    #overlay.hidden { display: none; }
    .code-box {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 36px 32px;
      max-width: 360px; width: 90%;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    .code-box h1 {
      font-family: 'Nunito', sans-serif;
      color: #0a4d6e; font-size: 26px; margin-bottom: 8px;
    }
    .code-box p { color: #666; font-size: 15px; margin-bottom: 20px; }
    .code-box input {
      width: 100%; padding: 14px;
      border: 2px solid #ddd; border-radius: 12px;
      font-size: 20px; text-align: center;
      letter-spacing: 8px; margin-bottom: 16px;
      -webkit-appearance: none;
    }
    .code-box input:focus { outline: none; border-color: #14a3c7; }
    .code-box button {
      width: 100%; padding: 14px;
      background: #0d7fa5; color: white; border: none;
      border-radius: 12px; font-size: 17px;
      font-weight: 600; cursor: pointer; min-height: 48px;
    }
    .code-box button:active { background: #0a6a8a; }
    .code-box .error { color: #c00; font-size: 14px; margin-top: 12px; min-height: 20px; }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="labels"><div id="title-label">Lily's Turtles</div></div>

  <div id="overlay">
    <div class="code-box">
      <h1>Lily's Turtles</h1>
      <p>Enter the Turtle Code</p>
      <input type="text" id="codeInput" inputmode="numeric" pattern="\d*" maxlength="10" autocomplete="off">
      <button id="codeSubmit">Enter</button>
      <div class="error" id="codeError"></div>
    </div>
  </div>

  <script type="importmap">
  { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js" } }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // --- DOM ---
    const container = document.getElementById('container');
    const labelsDiv = document.getElementById('labels');
    const titleLabel = document.getElementById('title-label');
    const overlay = document.getElementById('overlay');
    const codeInput = document.getElementById('codeInput');
    const codeSubmit = document.getElementById('codeSubmit');
    const codeError = document.getElementById('codeError');

    // --- State ---
    let eventCode = '';
    const turtleMap = new Map();
    let aquariumRunning = false;
    let pollTimer = null;
    let titleOpacity = 0;
    let startTime = 0;

    // --- Tank ---
    const TANK = { xMin: -13, xMax: 13, yMin: -6, yMax: 6, zMin: -7, zMax: 7 };

    // --- Scene ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x041526);

    const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 9, 22);
    camera.lookAt(0, -1, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 12, 8);
    scene.add(dirLight);
    const fillLight = new THREE.DirectionalLight(0x4488cc, 0.3);
    fillLight.position.set(-3, 10, -2);
    scene.add(fillLight);

    // --- Resize ---
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // --- Shared geometry & materials ---
    const shellGeo = new THREE.SphereGeometry(1, 32, 16);
    const headGeo = new THREE.SphereGeometry(1, 12, 8);
    const frontFlipGeo = new THREE.SphereGeometry(1, 10, 6);
    const backFlipGeo = new THREE.SphereGeometry(1, 8, 6);
    const tailGeo = new THREE.ConeGeometry(0.06, 0.3, 6);
    const eyeGeo = new THREE.SphereGeometry(0.038, 8, 6);
    const pupilGeo = new THREE.SphereGeometry(0.024, 6, 4);

    const skinMat = new THREE.MeshStandardMaterial({ color: 0x5A8A3A, roughness: 0.8 });
    const darkSkinMat = new THREE.MeshStandardMaterial({ color: 0x4A7A2E, roughness: 0.8 });
    const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const pupilMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

    // --- Cake geometry & materials ---
    const cakeBottomGeo = new THREE.CylinderGeometry(0.38, 0.40, 0.22, 20);
    const cakeTopGeo = new THREE.CylinderGeometry(0.28, 0.30, 0.18, 20);
    const frostingGeo = new THREE.CylinderGeometry(0.31, 0.31, 0.04, 20);
    const candleGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.22, 6);
    const flameGeo = new THREE.ConeGeometry(0.04, 0.1, 6);
    const flameGlowGeo = new THREE.SphereGeometry(0.05, 6, 4);

    const cakeMat = new THREE.MeshStandardMaterial({ color: 0xF5D6C0, roughness: 0.9 }); // vanilla sponge
    const frostingMat = new THREE.MeshStandardMaterial({ color: 0xFFF5F5, roughness: 0.6 }); // white frosting
    const frostingPinkMat = new THREE.MeshStandardMaterial({ color: 0xF8B4C8, roughness: 0.6 }); // pink frosting trim
    const candleMat = new THREE.MeshStandardMaterial({ color: 0x7EC8E3, roughness: 0.5 }); // light blue candles
    const flameMat = new THREE.MeshStandardMaterial({
      color: 0xFFAA22, emissive: 0xFF6600, emissiveIntensity: 1.2,
      transparent: true, opacity: 0.95,
    });
    const flameInnerMat = new THREE.MeshStandardMaterial({
      color: 0xFFEE88, emissive: 0xFFDD44, emissiveIntensity: 1.5,
      transparent: true, opacity: 0.9,
    });

    function createBirthdayCake() {
      const cake = new THREE.Group();
      cake.name = 'cake';

      // Bottom tier
      const bottom = new THREE.Mesh(cakeBottomGeo, cakeMat);
      bottom.position.y = 0.11;
      cake.add(bottom);

      // Pink frosting ring on bottom tier
      const trim = new THREE.Mesh(frostingGeo, frostingPinkMat);
      trim.scale.set(1.3, 1, 1.3);
      trim.position.y = 0.22;
      cake.add(trim);

      // Top tier
      const top = new THREE.Mesh(cakeTopGeo, cakeMat);
      top.position.y = 0.32;
      cake.add(top);

      // White frosting on top
      const frostTop = new THREE.Mesh(frostingGeo, frostingMat);
      frostTop.position.y = 0.42;
      cake.add(frostTop);

      // 3 candles with flames
      const candlePositions = [
        { x: -0.1, z: 0 },
        { x:  0.1, z: -0.08 },
        { x:  0.05, z: 0.1 },
      ];
      const flames = [];

      for (let i = 0; i < candlePositions.length; i++) {
        const cp = candlePositions[i];

        // Candle stick
        const candle = new THREE.Mesh(candleGeo, candleMat);
        candle.position.set(cp.x, 0.53, cp.z);
        cake.add(candle);

        // Outer flame (orange)
        const flame = new THREE.Mesh(flameGeo, flameMat);
        flame.position.set(cp.x, 0.69, cp.z);
        flame.name = 'flame_' + i;
        cake.add(flame);

        // Inner flame core (bright yellow)
        const inner = new THREE.Mesh(flameGeo, flameInnerMat);
        inner.scale.set(0.5, 0.6, 0.5);
        inner.position.set(cp.x, 0.68, cp.z);
        inner.name = 'flame_inner_' + i;
        cake.add(inner);

        flames.push({ outer: flame, inner: inner, phase: i * 2.1 });
      }

      // Add a warm point light from the candles
      const candleLight = new THREE.PointLight(0xFF9933, 0.8, 5);
      candleLight.position.set(0, 0.75, 0);
      cake.add(candleLight);

      // Scale up and position on top of shell dome
      cake.scale.set(2, 2, 2);
      cake.position.set(0, 0.42, 0);

      return { cakeGroup: cake, flames };
    }

    // --- Hero shell texture (realistic sea turtle scute pattern) ---
    function createHeroTexture() {
      const W = 512, H = 1024; // top half = shell back, bottom half = belly
      const c = document.createElement('canvas');
      c.width = W; c.height = H;
      const x = c.getContext('2d');
      const MID = H / 2; // equator line

      // --- Top half: hexagonal honeycomb shell pattern ---
      // Dark grout base
      x.fillStyle = '#2E4010';
      x.fillRect(0, 0, W, MID);

      // Hex tile colors — alternating warm greens/golds
      const hexColors = [
        ['#C8D462', '#A4B44A', '#869832'],
        ['#B0C050', '#92A43C', '#78882C'],
        ['#D4DC6E', '#B8C254', '#9AA840'],
        ['#BCC858', '#9CAC40', '#809430'],
      ];

      // Draw a single filled hexagon
      function hex(cx, cy, r, colorIdx) {
        const col = hexColors[colorIdx % hexColors.length];
        x.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 3 * i - Math.PI / 6;
          const px = cx + r * Math.cos(angle);
          const py = cy + r * Math.sin(angle);
          i === 0 ? x.moveTo(px, py) : x.lineTo(px, py);
        }
        x.closePath();

        // Gradient fill: bright center, darker edges
        const gf = x.createRadialGradient(cx - r * 0.1, cy - r * 0.1, 0, cx, cy, r);
        gf.addColorStop(0, col[0]);
        gf.addColorStop(0.7, col[1]);
        gf.addColorStop(1, col[2]);
        x.fillStyle = gf;
        x.fill();

        // Dark groove border
        x.strokeStyle = '#263A0C';
        x.lineWidth = 3.5;
        x.stroke();

        // Inner growth ring
        x.beginPath();
        const ri = r * 0.55;
        for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 3 * i - Math.PI / 6;
          const px = cx + ri * Math.cos(angle);
          const py = cy + ri * Math.sin(angle);
          i === 0 ? x.moveTo(px, py) : x.lineTo(px, py);
        }
        x.closePath();
        x.strokeStyle = 'rgba(50, 70, 15, 0.35)';
        x.lineWidth = 1.5;
        x.stroke();
      }

      // Tile the top half with hexagons
      const R = 42; // hex radius
      const hexW = R * Math.sqrt(3);
      const hexH = R * 2;
      const cols = Math.ceil(W / hexW) + 2;
      const rows = Math.ceil(MID / (hexH * 0.75)) + 2;

      for (let row = -1; row < rows; row++) {
        for (let col = -1; col < cols; col++) {
          const cx = col * hexW + (row % 2 ? hexW / 2 : 0);
          const cy = row * hexH * 0.75;
          if (cy > MID + R) continue;
          const ci = (row * 7 + col * 3) % hexColors.length;
          // Slight random variation in size for organic feel
          const rv = R * (0.96 + ((row * 13 + col * 7) % 11) / 11 * 0.08);
          hex(cx, cy, rv, Math.abs(ci));
        }
      }

      // Golden shimmer highlight
      const glow = x.createRadialGradient(W/2, MID * 0.4, 0, W/2, MID * 0.4, W * 0.4);
      glow.addColorStop(0, 'rgba(220, 200, 100, 0.15)');
      glow.addColorStop(1, 'rgba(220, 200, 100, 0)');
      x.fillStyle = glow;
      x.fillRect(0, 0, W, MID);

      // --- Bottom half: green/yellow belly ---
      const bellyGrad = x.createLinearGradient(0, MID, 0, H);
      bellyGrad.addColorStop(0, '#5A7A2E');
      bellyGrad.addColorStop(0.3, '#6A8A35');
      bellyGrad.addColorStop(1, '#4A6A25');
      x.fillStyle = bellyGrad;
      x.fillRect(0, MID, W, MID);

      // --- Dividing line at equator ---
      x.strokeStyle = '#3A5A18';
      x.lineWidth = 4;
      x.beginPath();
      x.moveTo(0, MID);
      x.lineTo(W, MID);
      x.stroke();

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    // --- Turtle group factory ---
    // Local space: -Z = forward, +Y = up (shell top)
    function createTurtleGroup(shellMaterial) {
      const group = new THREE.Group();

      // Shell dome
      const shell = new THREE.Mesh(shellGeo, shellMaterial);
      shell.scale.set(1.2, 0.48, 1.4);
      group.add(shell);

      // Big loggerhead head
      const head = new THREE.Mesh(headGeo, skinMat);
      head.scale.set(0.38, 0.30, 0.45);
      head.position.set(0, 0.04, -1.25);
      group.add(head);

      // Slightly darker top of head
      const headTop = new THREE.Mesh(headGeo, darkSkinMat);
      headTop.scale.set(0.35, 0.22, 0.40);
      headTop.position.set(0, 0.12, -1.25);
      group.add(headTop);

      // Eyes (bigger, wider apart for loggerhead)
      for (const side of [-1, 1]) {
        const eye = new THREE.Mesh(eyeGeo, eyeWhiteMat);
        eye.position.set(side * 0.22, 0.10, -1.52);
        eye.scale.set(1.3, 1.3, 1.3);
        group.add(eye);
        const pupil = new THREE.Mesh(pupilGeo, pupilMat);
        pupil.position.set(side * 0.23, 0.10, -1.56);
        pupil.scale.set(1.3, 1.3, 1.3);
        group.add(pupil);
      }

      // Front flippers (long paddles)
      const frontFlipData = [
        { px: -0.7, pz: -0.35, ox: -0.72, flipY: -0.2, name: 'fl_fl' },
        { px:  0.7, pz: -0.35, ox:  0.72, flipY:  0.2, name: 'fl_fr' },
      ];
      for (const f of frontFlipData) {
        const pivot = new THREE.Group();
        pivot.position.set(f.px, -0.1, f.pz);
        pivot.name = f.name;
        const mesh = new THREE.Mesh(frontFlipGeo, skinMat);
        mesh.scale.set(1.4, 0.05, 0.38);
        mesh.position.set(f.ox, 0, -0.1);
        mesh.rotation.y = f.flipY;
        pivot.add(mesh);
        group.add(pivot);
      }

      // Back flippers (smaller paddles)
      const backFlipData = [
        { px: -0.42, pz: 0.8, ox: -0.3, name: 'fl_bl' },
        { px:  0.42, pz: 0.8, ox:  0.3, name: 'fl_br' },
      ];
      for (const f of backFlipData) {
        const pivot = new THREE.Group();
        pivot.position.set(f.px, -0.1, f.pz);
        pivot.name = f.name;
        const mesh = new THREE.Mesh(backFlipGeo, darkSkinMat);
        mesh.scale.set(0.55, 0.04, 0.32);
        mesh.position.set(f.ox, 0, 0);
        pivot.add(mesh);
        group.add(pivot);
      }

      // Tail
      const tail = new THREE.Mesh(tailGeo, darkSkinMat);
      tail.position.set(0, -0.04, 1.28);
      tail.rotation.x = Math.PI / 2;
      group.add(tail);

      return group;
    }

    // --- Texture helpers ---
    // Creates a texture with drawing on white (top half) and green belly (bottom half).
    // The sphere UV maps v=0 at top pole to v=1 at bottom pole, so the
    // top half of the canvas covers the shell back (visible) and the
    // bottom half covers the belly (green).
    function loadShellTexture(dataURI) {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => {
          const w = img.width;
          const h = img.height;
          const c = document.createElement('canvas');
          c.width = w;
          c.height = h * 2; // top half = drawing, bottom half = belly
          const ctx = c.getContext('2d');

          // --- Top half: white background + drawing (shell back) ---
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, w, h);
          ctx.drawImage(img, 0, 0);

          // --- Bottom half: green belly ---
          ctx.fillStyle = '#4A7A2E';
          ctx.fillRect(0, h, w, h);

          // --- Dividing line ---
          ctx.strokeStyle = '#3A6A1E';
          ctx.lineWidth = Math.max(2, h / 100);
          ctx.beginPath();
          ctx.moveTo(0, h);
          ctx.lineTo(w, h);
          ctx.stroke();

          const tex = new THREE.CanvasTexture(c);
          tex.colorSpace = THREE.SRGBColorSpace;
          resolve(tex);
        };
        img.onerror = () => resolve(null);
        img.src = dataURI;
      });
    }

    // --- Angle helpers ---
    function normalizeAngle(a) {
      a = a % (Math.PI * 2);
      if (a > Math.PI) a -= Math.PI * 2;
      if (a < -Math.PI) a += Math.PI * 2;
      return a;
    }
    function lerpAngle(cur, tgt, t) {
      return cur + normalizeAngle(tgt - cur) * t;
    }

    // --- Create turtle from server data ---
    async function createTurtle3D(st) {
      const isHero = st.isHero || false;
      const scale = isHero ? 1.4 : 1.0;

      let shellMat;
      if (isHero) {
        const tex = createHeroTexture();
        shellMat = new THREE.MeshStandardMaterial({
          map: tex, color: 0xd4dd88,
          emissive: 0x2a1f00, emissiveIntensity: 0.25,
          roughness: 0.6, side: THREE.DoubleSide,
        });
      } else if (st.imageData) {
        const tex = await loadShellTexture(st.imageData);
        shellMat = new THREE.MeshStandardMaterial({
          map: tex || undefined,
          color: tex ? 0xffffff : 0xA8D5A2,
          roughness: 0.65, side: THREE.DoubleSide,
        });
      } else {
        shellMat = new THREE.MeshStandardMaterial({
          color: 0xA8D5A2, roughness: 0.65, side: THREE.DoubleSide,
        });
      }

      const group = createTurtleGroup(shellMat);
      group.scale.set(scale, scale, scale);

      // Birthday cake on the hero turtle
      let flames = null;
      if (isHero) {
        const cakeData = createBirthdayCake();
        group.add(cakeData.cakeGroup);
        flames = cakeData.flames;
      }

      // Initial position & heading
      const dir = st.direction || 1;
      // direction 1 = moving right (+X), heading = -π/2
      // direction -1 = moving left (-X), heading = π/2
      const initHeading = dir > 0 ? -Math.PI / 2 : Math.PI / 2;
      const startX = dir > 0 ? TANK.xMin - 2 : TANK.xMax + 2;
      const startY = (Math.random() - 0.5) * 6;
      const startZ = (Math.random() - 0.5) * 8;
      group.position.set(startX, startY, startZ);
      group.rotation.order = 'YXZ';

      scene.add(group);

      // Map server speed (30-100) to 3D speed
      const mapped = 1.0 + ((st.speed - 30) / 70) * 2.5;
      const speed = isHero ? mapped * 0.65 : mapped;

      // Label
      const labelDiv = document.createElement('div');
      labelDiv.className = 'turtle-label';
      labelDiv.textContent = st.name || '';
      labelDiv.style.opacity = '0';
      labelsDiv.appendChild(labelDiv);

      const state = {
        id: st.id,
        name: st.name || '',
        isHero,
        speed,
        // Orientation
        heading: initHeading,
        swimPitch: 0,
        // Double-smoothed targets: raw → smooth → heading
        rawTargetH: initHeading,
        rawTargetP: 0,
        smoothTargetH: initHeading,
        smoothTargetP: 0,
        wanderHeading: initHeading,
        wanderPitch: 0,
        wanderTimer: 3 + Math.random() * 4,
        wanderInterval: 5 + Math.random() * 6,
        // Visual
        baseTilt: -0.42,   // nose down → shows back to camera
        phase: st.phase || Math.random() * Math.PI * 2,
        flipperFreq: 2.5 + speed * 0.8,
        bankAngle: 0,      // smoothed bank
        // Name
        nameOpacity: 0,
        nameTimer: 0,
        namePhase: st.name ? 'fadein' : 'done',
      };

      return { group, state, labelDiv, shellMat, flames };
    }

    // --- Movement ---
    function updateTurtleMovement(entry, dt, time) {
      const s = entry.state;
      const g = entry.group;
      const pos = g.position;

      // --- Wander: gradually drift toward new random directions ---
      s.wanderTimer -= dt;
      if (s.wanderTimer <= 0) {
        s.wanderTimer = s.wanderInterval;
        // Gentle heading change: ±50° from current
        s.wanderHeading = s.heading + (Math.random() - 0.5) * 1.75;
        // Gentle pitch: ±18°
        s.wanderPitch = (Math.random() - 0.5) * 0.6;
      }

      // --- Compute desired direction (wander + wall avoidance) ---
      let desX = -Math.sin(s.wanderHeading) * Math.cos(s.wanderPitch);
      let desY = Math.sin(s.wanderPitch);
      let desZ = -Math.cos(s.wanderHeading) * Math.cos(s.wanderPitch);

      // Wall avoidance: gentle repulsion that grows near walls
      const margin = 4;
      const force = 2.5;
      const nudge = (dist, limit) => {
        const t = Math.max(0, 1 - dist / limit);
        return t * t * force;
      };
      if (pos.x < TANK.xMin + margin) desX += nudge(pos.x - TANK.xMin, margin);
      if (pos.x > TANK.xMax - margin) desX -= nudge(TANK.xMax - pos.x, margin);
      if (pos.y < TANK.yMin + margin) desY += nudge(pos.y - TANK.yMin, margin);
      if (pos.y > TANK.yMax - margin) desY -= nudge(TANK.yMax - pos.y, margin);
      if (pos.z < TANK.zMin + margin) desZ += nudge(pos.z - TANK.zMin, margin);
      if (pos.z > TANK.zMax - margin) desZ -= nudge(TANK.zMax - pos.z, margin);

      // Raw target from desired direction (can jump)
      const hLen = Math.sqrt(desX * desX + desZ * desZ);
      s.rawTargetH = Math.atan2(-desX, -desZ);
      s.rawTargetP = Math.atan2(desY, Math.max(hLen, 0.01));
      s.rawTargetP = Math.max(-0.35, Math.min(0.35, s.rawTargetP));

      // Double-smoothing: raw → smoothTarget → heading
      // Layer 1: smooth the target itself (absorbs jumps)
      const smoothRate = Math.min(1, dt * 0.8);
      s.smoothTargetH = lerpAngle(s.smoothTargetH, s.rawTargetH, smoothRate);
      s.smoothTargetP += (s.rawTargetP - s.smoothTargetP) * smoothRate;

      // Layer 2: heading follows smoothed target
      const turnRate = Math.min(1, dt * 1.2);
      s.heading = lerpAngle(s.heading, s.smoothTargetH, turnRate);
      s.swimPitch += (s.smoothTargetP - s.swimPitch) * turnRate;

      // --- Move forward along heading/pitch ---
      const cp = Math.cos(s.swimPitch);
      const dx = -Math.sin(s.heading) * cp;
      const dy = Math.sin(s.swimPitch);
      const dz = -Math.cos(s.heading) * cp;

      pos.x += dx * s.speed * dt;
      pos.y += dy * s.speed * dt;
      pos.z += dz * s.speed * dt;

      // Gentle bob
      pos.y += Math.sin(time * 1.2 + s.phase) * 0.012;

      // Hard clamp (safety net)
      pos.x = Math.max(TANK.xMin, Math.min(TANK.xMax, pos.x));
      pos.y = Math.max(TANK.yMin, Math.min(TANK.yMax, pos.y));
      pos.z = Math.max(TANK.zMin, Math.min(TANK.zMax, pos.z));

      // --- Visual rotation (all smoothed) ---
      const swimWobble = Math.sin(time * 1.8 + s.phase) * 0.06;
      g.rotation.y = s.heading;
      g.rotation.x = s.baseTilt + s.swimPitch * 0.7 + swimWobble;

      // Smooth bank into turns
      const desiredBank = -normalizeAngle(s.smoothTargetH - s.heading) * 0.2;
      s.bankAngle += (desiredBank - s.bankAngle) * Math.min(1, dt * 2);
      g.rotation.z = s.bankAngle;

      // --- Flipper animation ---
      const ft = time * s.flipperFreq;
      for (const child of g.children) {
        switch (child.name) {
          case 'fl_fl': child.rotation.z =  Math.sin(ft) * 0.55; break;
          case 'fl_fr': child.rotation.z = -Math.sin(ft) * 0.55; break;
          case 'fl_bl': child.rotation.z =  Math.sin(ft * 0.7 + 1.5) * 0.2; break;
          case 'fl_br': child.rotation.z = -Math.sin(ft * 0.7 + 1.5) * 0.2; break;
        }
      }

      // --- Flame animation (hero cake) ---
      if (entry.flames) {
        for (const f of entry.flames) {
          const flicker = time * 8 + f.phase;
          // Outer flame: scale wobble + slight sway
          f.outer.scale.y = 0.85 + Math.sin(flicker) * 0.2 + Math.sin(flicker * 2.3) * 0.1;
          f.outer.scale.x = 0.9 + Math.sin(flicker * 1.7) * 0.15;
          f.outer.scale.z = 0.9 + Math.cos(flicker * 1.3) * 0.15;
          f.outer.position.x = f.inner.position.x + Math.sin(flicker * 1.1) * 0.008;
          // Inner flame: faster flicker
          f.inner.scale.y = 0.5 + Math.sin(flicker * 1.5) * 0.15;
          f.inner.scale.x = 0.4 + Math.sin(flicker * 2.1) * 0.1;
        }
      }

      // --- Name fade ---
      if (s.namePhase === 'fadein') {
        s.nameOpacity = Math.min(1, s.nameOpacity + dt);
        if (s.nameOpacity >= 1) { s.namePhase = 'visible'; s.nameTimer = 0; }
      } else if (s.namePhase === 'visible') {
        s.nameTimer += dt;
        if (s.nameTimer >= 30) s.namePhase = 'fadeout';
      } else if (s.namePhase === 'fadeout') {
        s.nameOpacity = Math.max(0, s.nameOpacity - dt);
        if (s.nameOpacity <= 0) s.namePhase = 'done';
      }
    }

    // --- Particles ---
    const PARTICLE_COUNT = 50;
    const pPos = new Float32Array(PARTICLE_COUNT * 3);
    (function initParticles() {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        pPos[i*3]   = (Math.random()-0.5) * (TANK.xMax-TANK.xMin);
        pPos[i*3+1] = (Math.random()-0.5) * (TANK.yMax-TANK.yMin);
        pPos[i*3+2] = (Math.random()-0.5) * (TANK.zMax-TANK.zMin);
      }
    })();
    const pGeo = new THREE.BufferGeometry();
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    scene.add(new THREE.Points(pGeo, new THREE.PointsMaterial({
      color: 0xccddff, size: 0.08, transparent: true, opacity: 0.45, sizeAttenuation: true,
    })));

    function updateParticles(dt) {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        pPos[i*3+1] += dt * 0.35;
        pPos[i*3]   += Math.sin(i*1.7 + performance.now()*0.001) * 0.002;
        if (pPos[i*3+1] > TANK.yMax) {
          pPos[i*3+1] = TANK.yMin;
          pPos[i*3]   = (Math.random()-0.5) * (TANK.xMax-TANK.xMin);
          pPos[i*3+2] = (Math.random()-0.5) * (TANK.zMax-TANK.zMin);
        }
      }
      pGeo.attributes.position.needsUpdate = true;
    }

    // --- Projection helper ---
    const _v = new THREE.Vector3();
    function projectToScreen(position) {
      _v.copy(position).project(camera);
      return {
        x: ( _v.x * 0.5 + 0.5) * innerWidth,
        y: (-_v.y * 0.5 + 0.5) * innerHeight,
      };
    }

    // --- Labels ---
    function updateLabels() {
      for (const e of turtleMap.values()) {
        const div = e.labelDiv;
        if (e.state.nameOpacity > 0 && e.state.name) {
          const p = projectToScreen(e.group.position);
          div.style.left = p.x + 'px';
          div.style.top = (p.y - 35) + 'px';
          div.style.opacity = String(e.state.nameOpacity);
        } else {
          div.style.opacity = '0';
        }
      }
    }

    function updateTitle() {
      const hero = turtleMap.get('hero');
      if (!hero) { titleLabel.style.opacity = '0'; return; }
      titleLabel.style.opacity = String(titleOpacity);
      const p = projectToScreen(hero.group.position);
      titleLabel.style.left = p.x + 'px';
      titleLabel.style.top = Math.max(40, p.y - 160) + 'px';
      titleLabel.style.fontSize = Math.min(48, innerWidth / 10) + 'px';
    }

    // --- Polling ---
    async function pollTurtles() {
      try {
        const knownIds = Array.from(turtleMap.keys()).join(',');
        const res = await fetch(`/api/turtles?eventCode=${encodeURIComponent(eventCode)}&knownIds=${encodeURIComponent(knownIds)}`);
        if (!res.ok) return;
        const data = await res.json();
        const serverIds = new Set();

        for (const st of data.turtles) {
          serverIds.add(st.id);
          if (turtleMap.has(st.id)) {
            const e = turtleMap.get(st.id);
            e.state.name = st.name;
            e.labelDiv.textContent = st.name || '';
          } else {
            const e = await createTurtle3D(st);
            turtleMap.set(st.id, e);
          }
        }

        for (const [id, e] of turtleMap) {
          if (!serverIds.has(id)) {
            scene.remove(e.group);
            e.labelDiv.remove();
            if (e.shellMat) {
              if (e.shellMat.map) e.shellMat.map.dispose();
              e.shellMat.dispose();
            }
            turtleMap.delete(id);
          }
        }
      } catch {}
    }

    function startPolling() {
      pollTurtles();
      pollTimer = setInterval(pollTurtles, 3000);
    }

    // --- Animation loop ---
    let lastFrame = performance.now();

    function animate(now) {
      if (!aquariumRunning) return;
      requestAnimationFrame(animate);

      const dt = Math.min((now - lastFrame) / 1000, 0.1);
      lastFrame = now;
      const time = (now / 1000) - startTime;

      if (titleOpacity < 1) titleOpacity = Math.min(1, titleOpacity + dt * 0.5);

      for (const e of turtleMap.values()) updateTurtleMovement(e, dt, time);
      updateParticles(dt);
      updateLabels();
      updateTitle();
      renderer.render(scene, camera);
    }

    // --- Code entry ---
    async function validateCode(code) {
      try { return (await fetch(`/api/turtles?eventCode=${encodeURIComponent(code)}&knownIds=`)).status; }
      catch { return 0; }
    }

    async function handleCodeSubmit() {
      const code = codeInput.value.trim();
      if (!code) return;
      codeError.textContent = '';
      codeSubmit.disabled = true;
      codeSubmit.textContent = 'Checking...';
      const status = await validateCode(code);
      if (status === 200) {
        eventCode = code;
        localStorage.setItem('turtleCode', code);
        overlay.classList.add('hidden');
        startAquarium();
      } else if (status === 429) {
        codeError.textContent = 'Too many attempts. Wait a moment.';
      } else if (status === 403) {
        codeError.textContent = 'Wrong code. Try again!';
      } else {
        codeError.textContent = 'Connection error. Try again.';
      }
      codeSubmit.disabled = false;
      codeSubmit.textContent = 'Enter';
    }

    codeSubmit.addEventListener('click', handleCodeSubmit);
    codeInput.addEventListener('keydown', e => { if (e.key === 'Enter') handleCodeSubmit(); });

    function startAquarium() {
      aquariumRunning = true;
      startTime = performance.now() / 1000;
      lastFrame = performance.now();
      startPolling();
      requestAnimationFrame(animate);
    }

    // --- Init ---
    (async () => {
      const stored = localStorage.getItem('turtleCode');
      if (stored) {
        const status = await validateCode(stored);
        if (status === 200) {
          eventCode = stored;
          overlay.classList.add('hidden');
          startAquarium();
          return;
        }
      }
      codeInput.focus();
    })();
  </script>
</body>
</html>

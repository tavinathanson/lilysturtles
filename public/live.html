<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Lily's Turtles</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: #041526;
    }
    #container { width: 100%; height: 100%; }
    #container canvas { display: block; }
    #labels {
      position: fixed; inset: 0;
      pointer-events: none; z-index: 1;
    }
    .turtle-label {
      position: absolute;
      color: white;
      font-family: 'Nunito', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-weight: 800;
      font-size: 20px;
      text-shadow:
        0 0 8px rgba(0,0,0,0.95),
        0 0 16px rgba(0,0,0,0.7),
        0 2px 4px rgba(0,0,0,0.9),
        1px 1px 0 rgba(0,0,0,0.8),
        -1px -1px 0 rgba(0,0,0,0.8),
        1px -1px 0 rgba(0,0,0,0.8),
        -1px 1px 0 rgba(0,0,0,0.8);
      transform: translate(-50%, -100%);
      white-space: nowrap;
    }
    #title-label {
      position: absolute;
      color: white;
      font-family: 'Nunito', sans-serif;
      font-weight: 800;
      font-size: 48px;
      text-shadow:
        0 0 20px rgba(255,255,255,0.7),
        0 0 40px rgba(255,255,255,0.35),
        0 0 6px rgba(0,0,0,0.9),
        0 3px 6px rgba(0,0,0,0.8),
        2px 2px 0 rgba(0,0,0,0.6),
        -2px -2px 0 rgba(0,0,0,0.6),
        2px -2px 0 rgba(0,0,0,0.6),
        -2px 2px 0 rgba(0,0,0,0.6);
      transform: translate(-50%, -100%);
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
    }
    #overlay {
      position: fixed; inset: 0;
      background: rgba(4, 21, 38, 0.92);
      display: flex; align-items: center; justify-content: center;
      z-index: 10;
    }
    #overlay.hidden { display: none; }
    .code-box {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 36px 32px;
      max-width: 360px; width: 90%;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    .code-box h1 {
      font-family: 'Nunito', sans-serif;
      color: #0a4d6e; font-size: 26px; margin-bottom: 8px;
    }
    .code-box p { color: #666; font-size: 15px; margin-bottom: 20px; }
    .code-box input {
      width: 100%; padding: 14px;
      border: 2px solid #ddd; border-radius: 12px;
      font-size: 20px; text-align: center;
      letter-spacing: 8px; margin-bottom: 16px;
      -webkit-appearance: none;
    }
    .code-box input:focus { outline: none; border-color: #14a3c7; }
    .code-box button {
      width: 100%; padding: 14px;
      background: #0d7fa5; color: white; border: none;
      border-radius: 12px; font-size: 17px;
      font-weight: 600; cursor: pointer; min-height: 48px;
    }
    .code-box button:active { background: #0a6a8a; }
    .code-box .error { color: #c00; font-size: 14px; margin-top: 12px; min-height: 20px; }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="labels"><div id="title-label">Lily's Turtles</div></div>

  <div id="overlay">
    <div class="code-box">
      <h1>Lily's Turtles</h1>
      <p>Enter the Turtle Code</p>
      <input type="text" id="codeInput" inputmode="numeric" pattern="\d*" maxlength="10" autocomplete="off">
      <button id="codeSubmit">Enter</button>
      <div class="error" id="codeError"></div>
    </div>
  </div>

  <script type="importmap">
  { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js" } }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // --- DOM ---
    const container = document.getElementById('container');
    const labelsDiv = document.getElementById('labels');
    const titleLabel = document.getElementById('title-label');
    const overlay = document.getElementById('overlay');
    const codeInput = document.getElementById('codeInput');
    const codeSubmit = document.getElementById('codeSubmit');
    const codeError = document.getElementById('codeError');

    // --- State ---
    let eventCode = '';
    const turtleMap = new Map();
    let aquariumRunning = false;
    let pollTimer = null;
    const processedCommands = new Set();
    let titleOpacity = 0;
    let startTime = 0;

    // --- Tank ---
    const TANK = { xMin: -13, xMax: 13, yMin: -6, yMax: 6, zMin: -7, zMax: 16 };

    // --- Scene ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x041526);

    const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 9, 22);
    camera.lookAt(0, -1, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(5, 12, 8);
    scene.add(dirLight);
    const fillLight = new THREE.DirectionalLight(0x4488cc, 0.45);
    fillLight.position.set(-3, 10, -2);
    scene.add(fillLight);
    // Rim light from behind to outline turtles against the dark background
    const rimLight = new THREE.DirectionalLight(0x88bbee, 0.35);
    rimLight.position.set(0, 5, -10);
    scene.add(rimLight);

    // --- Resize ---
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // --- Shared geometry & materials ---
    // Shell uses custom UVs: top-down planar projection on upper hemisphere
    // so drawings appear flat/centered on the shell back, not wrapped spherically.
    const shellGeo = new THREE.SphereGeometry(1, 32, 16);
    {
      const pos = shellGeo.attributes.position;
      const uv = shellGeo.attributes.uv;
      // CanvasTexture flipY=true means v=1 → canvas top (drawing), v=0 → canvas bottom (belly).
      // Texture layout: canvas top half = drawing on white, canvas bottom half = green belly.
      // So: shell back (y>=0) → v: 0.5–1.0, belly (y<0) → v: 0–0.5.
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const z = pos.getZ(i);
        if (y >= 0) {
          // Top hemisphere: planar projection from above into drawing region (v: 0.5–1.0)
          const u = (x + 1) / 2;
          const v = 0.5 + (1 - z) / 2 * 0.5; // z=-1 (head) → v=1 (top of drawing), z=1 (tail) → v=0.5
          uv.setXY(i, u, v);
        } else {
          // Bottom hemisphere: green belly region (v: 0–0.5)
          uv.setXY(i, 0.5, 0.25);
        }
      }
      uv.needsUpdate = true;
    }
    const headGeo = new THREE.SphereGeometry(1, 12, 8);
    const frontFlipGeo = new THREE.SphereGeometry(1, 10, 6);
    const backFlipGeo = new THREE.SphereGeometry(1, 8, 6);
    const tailGeo = new THREE.ConeGeometry(0.06, 0.3, 6);
    const eyeGeo = new THREE.SphereGeometry(0.038, 8, 6);
    const pupilGeo = new THREE.SphereGeometry(0.024, 6, 4);

    const skinMat = new THREE.MeshStandardMaterial({ color: 0x5A8A3A, roughness: 0.75, emissive: 0x0a1a05, emissiveIntensity: 0.2 });
    const darkSkinMat = new THREE.MeshStandardMaterial({ color: 0x4A7A2E, roughness: 0.75, emissive: 0x081505, emissiveIntensity: 0.2 });
    const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const pupilMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

    // --- Cake geometry & materials ---
    const cakeBottomGeo = new THREE.CylinderGeometry(0.38, 0.40, 0.22, 20);
    const cakeTopGeo = new THREE.CylinderGeometry(0.28, 0.30, 0.18, 20);
    const frostingGeo = new THREE.CylinderGeometry(0.31, 0.31, 0.04, 20);
    const candleGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.22, 6);
    const flameGeo = new THREE.ConeGeometry(0.04, 0.1, 6);
    const flameGlowGeo = new THREE.SphereGeometry(0.05, 6, 4);

    const cakeMat = new THREE.MeshStandardMaterial({ color: 0xF5D6C0, roughness: 0.9 }); // vanilla sponge
    const frostingMat = new THREE.MeshStandardMaterial({ color: 0xFFF5F5, roughness: 0.6 }); // white frosting
    const frostingPinkMat = new THREE.MeshStandardMaterial({ color: 0xF8B4C8, roughness: 0.6 }); // pink frosting trim
    const candleMat = new THREE.MeshStandardMaterial({ color: 0x7EC8E3, roughness: 0.5 }); // light blue candles
    const flameMat = new THREE.MeshStandardMaterial({
      color: 0xFFAA22, emissive: 0xFF6600, emissiveIntensity: 1.2,
      transparent: true, opacity: 0.95,
    });
    const flameInnerMat = new THREE.MeshStandardMaterial({
      color: 0xFFEE88, emissive: 0xFFDD44, emissiveIntensity: 1.5,
      transparent: true, opacity: 0.9,
    });

    function createBirthdayCake() {
      const cake = new THREE.Group();
      cake.name = 'cake';

      // Bottom tier
      const bottom = new THREE.Mesh(cakeBottomGeo, cakeMat);
      bottom.position.y = 0.11;
      cake.add(bottom);

      // Pink frosting ring on bottom tier
      const trim = new THREE.Mesh(frostingGeo, frostingPinkMat);
      trim.scale.set(1.3, 1, 1.3);
      trim.position.y = 0.22;
      cake.add(trim);

      // Top tier
      const top = new THREE.Mesh(cakeTopGeo, cakeMat);
      top.position.y = 0.32;
      cake.add(top);

      // White frosting on top
      const frostTop = new THREE.Mesh(frostingGeo, frostingMat);
      frostTop.position.y = 0.42;
      cake.add(frostTop);

      // 3 candles with flames
      const candlePositions = [
        { x: -0.1, z: 0 },
        { x:  0.1, z: -0.08 },
        { x:  0.05, z: 0.1 },
      ];
      const flames = [];

      for (let i = 0; i < candlePositions.length; i++) {
        const cp = candlePositions[i];

        // Candle stick
        const candle = new THREE.Mesh(candleGeo, candleMat);
        candle.position.set(cp.x, 0.53, cp.z);
        cake.add(candle);

        // Outer flame (orange)
        const flame = new THREE.Mesh(flameGeo, flameMat);
        flame.position.set(cp.x, 0.69, cp.z);
        flame.name = 'flame_' + i;
        cake.add(flame);

        // Inner flame core (bright yellow)
        const inner = new THREE.Mesh(flameGeo, flameInnerMat);
        inner.scale.set(0.5, 0.6, 0.5);
        inner.position.set(cp.x, 0.68, cp.z);
        inner.name = 'flame_inner_' + i;
        cake.add(inner);

        flames.push({ outer: flame, inner: inner, phase: i * 2.1 });
      }

      // Add a warm point light from the candles
      const candleLight = new THREE.PointLight(0xFF9933, 0.8, 5);
      candleLight.position.set(0, 0.75, 0);
      cake.add(candleLight);

      // Scale up and position on top of shell dome
      cake.scale.set(2, 2, 2);
      cake.position.set(0, 0.42, 0);

      return { cakeGroup: cake, flames };
    }

    // --- Hero shell texture (realistic sea turtle scute pattern) ---
    function createHeroTexture() {
      const W = 512, H = 1024; // top half = shell back, bottom half = belly
      const c = document.createElement('canvas');
      c.width = W; c.height = H;
      const x = c.getContext('2d');
      const MID = H / 2; // equator line

      // --- Top half: hexagonal honeycomb shell pattern ---
      // Dark grout base — deep for projector contrast
      x.fillStyle = '#1A2A08';
      x.fillRect(0, 0, W, MID);

      // Hex tile colors — saturated warm greens/golds for projector visibility
      const hexColors = [
        ['#D4E06A', '#A8B840', '#6E7E22'],
        ['#C0D050', '#8EA030', '#607818'],
        ['#E0E878', '#C0CC48', '#8A9830'],
        ['#CCDA58', '#98B030', '#6C8420'],
      ];

      // Draw a single filled hexagon
      function hex(cx, cy, r, colorIdx) {
        const col = hexColors[colorIdx % hexColors.length];
        x.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 3 * i - Math.PI / 6;
          const px = cx + r * Math.cos(angle);
          const py = cy + r * Math.sin(angle);
          i === 0 ? x.moveTo(px, py) : x.lineTo(px, py);
        }
        x.closePath();

        // Gradient fill: bright center, darker edges
        const gf = x.createRadialGradient(cx - r * 0.1, cy - r * 0.1, 0, cx, cy, r);
        gf.addColorStop(0, col[0]);
        gf.addColorStop(0.7, col[1]);
        gf.addColorStop(1, col[2]);
        x.fillStyle = gf;
        x.fill();

        // Dark groove border — thick for projector contrast
        x.strokeStyle = '#162808';
        x.lineWidth = 4.5;
        x.stroke();

        // Inner growth ring
        x.beginPath();
        const ri = r * 0.55;
        for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 3 * i - Math.PI / 6;
          const px = cx + ri * Math.cos(angle);
          const py = cy + ri * Math.sin(angle);
          i === 0 ? x.moveTo(px, py) : x.lineTo(px, py);
        }
        x.closePath();
        x.strokeStyle = 'rgba(50, 70, 15, 0.35)';
        x.lineWidth = 1.5;
        x.stroke();
      }

      // Tile the top half with hexagons
      const R = 42; // hex radius
      const hexW = R * Math.sqrt(3);
      const hexH = R * 2;
      const cols = Math.ceil(W / hexW) + 2;
      const rows = Math.ceil(MID / (hexH * 0.75)) + 2;

      for (let row = -1; row < rows; row++) {
        for (let col = -1; col < cols; col++) {
          const cx = col * hexW + (row % 2 ? hexW / 2 : 0);
          const cy = row * hexH * 0.75;
          if (cy > MID + R) continue;
          const ci = (row * 7 + col * 3) % hexColors.length;
          // Slight random variation in size for organic feel
          const rv = R * (0.96 + ((row * 13 + col * 7) % 11) / 11 * 0.08);
          hex(cx, cy, rv, Math.abs(ci));
        }
      }

      // Golden shimmer highlight
      const glow = x.createRadialGradient(W/2, MID * 0.4, 0, W/2, MID * 0.4, W * 0.4);
      glow.addColorStop(0, 'rgba(220, 200, 100, 0.15)');
      glow.addColorStop(1, 'rgba(220, 200, 100, 0)');
      x.fillStyle = glow;
      x.fillRect(0, 0, W, MID);

      // --- Bottom half: green/yellow belly ---
      const bellyGrad = x.createLinearGradient(0, MID, 0, H);
      bellyGrad.addColorStop(0, '#5A7A2E');
      bellyGrad.addColorStop(0.3, '#6A8A35');
      bellyGrad.addColorStop(1, '#4A6A25');
      x.fillStyle = bellyGrad;
      x.fillRect(0, MID, W, MID);

      // --- Dividing line at equator ---
      x.strokeStyle = '#3A5A18';
      x.lineWidth = 4;
      x.beginPath();
      x.moveTo(0, MID);
      x.lineTo(W, MID);
      x.stroke();

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    // --- Turtle group factory ---
    // Local space: -Z = forward, +Y = up (shell top)
    function createTurtleGroup(shellMaterial) {
      const group = new THREE.Group();

      // Shell dome
      const shell = new THREE.Mesh(shellGeo, shellMaterial);
      shell.scale.set(1.2, 0.48, 1.4);
      group.add(shell);

      // Big loggerhead head
      const head = new THREE.Mesh(headGeo, skinMat);
      head.scale.set(0.38, 0.30, 0.45);
      head.position.set(0, 0.04, -1.25);
      group.add(head);

      // Slightly darker top of head
      const headTop = new THREE.Mesh(headGeo, darkSkinMat);
      headTop.scale.set(0.35, 0.22, 0.40);
      headTop.position.set(0, 0.12, -1.25);
      group.add(headTop);

      // Eyes (bigger, wider apart for loggerhead)
      for (const side of [-1, 1]) {
        const eye = new THREE.Mesh(eyeGeo, eyeWhiteMat);
        eye.position.set(side * 0.22, 0.10, -1.52);
        eye.scale.set(1.3, 1.3, 1.3);
        group.add(eye);
        const pupil = new THREE.Mesh(pupilGeo, pupilMat);
        pupil.position.set(side * 0.23, 0.10, -1.56);
        pupil.scale.set(1.3, 1.3, 1.3);
        group.add(pupil);
      }

      // Front flippers (long paddles)
      const frontFlipData = [
        { px: -0.7, pz: -0.35, ox: -0.72, flipY: -0.2, name: 'fl_fl' },
        { px:  0.7, pz: -0.35, ox:  0.72, flipY:  0.2, name: 'fl_fr' },
      ];
      for (const f of frontFlipData) {
        const pivot = new THREE.Group();
        pivot.position.set(f.px, -0.1, f.pz);
        pivot.name = f.name;
        const mesh = new THREE.Mesh(frontFlipGeo, skinMat);
        mesh.scale.set(1.4, 0.05, 0.38);
        mesh.position.set(f.ox, 0, -0.1);
        mesh.rotation.y = f.flipY;
        pivot.add(mesh);
        group.add(pivot);
      }

      // Back flippers (smaller paddles)
      const backFlipData = [
        { px: -0.42, pz: 0.8, ox: -0.3, name: 'fl_bl' },
        { px:  0.42, pz: 0.8, ox:  0.3, name: 'fl_br' },
      ];
      for (const f of backFlipData) {
        const pivot = new THREE.Group();
        pivot.position.set(f.px, -0.1, f.pz);
        pivot.name = f.name;
        const mesh = new THREE.Mesh(backFlipGeo, darkSkinMat);
        mesh.scale.set(0.55, 0.04, 0.32);
        mesh.position.set(f.ox, 0, 0);
        pivot.add(mesh);
        group.add(pivot);
      }

      // Tail
      const tail = new THREE.Mesh(tailGeo, darkSkinMat);
      tail.position.set(0, -0.04, 1.28);
      tail.rotation.x = Math.PI / 2;
      group.add(tail);

      return group;
    }

    // --- Texture helpers ---
    // Creates a texture with drawing on white (top half) and green belly (bottom half).
    // The sphere UV maps v=0 at top pole to v=1 at bottom pole, so the
    // top half of the canvas covers the shell back (visible) and the
    // bottom half covers the belly (green).
    function loadShellTexture(dataURI) {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => {
          const w = img.width;
          const h = img.height;
          const c = document.createElement('canvas');
          c.width = w;
          c.height = h * 2; // top half = drawing, bottom half = belly
          const ctx = c.getContext('2d');

          // --- Top half: white background + drawing (shell back) ---
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, w, h);
          ctx.drawImage(img, 0, 0);

          // --- Boost contrast of uploaded drawing for projector visibility ---
          const imgData = ctx.getImageData(0, 0, w, h);
          const d = imgData.data;
          for (let i = 0; i < d.length; i += 4) {
            // Apply contrast curve: push darks darker, keep lights light
            for (let ch = 0; ch < 3; ch++) {
              let v = d[i + ch] / 255;
              // S-curve contrast boost
              v = v < 0.5
                ? 0.5 * Math.pow(2 * v, 1.5)
                : 1 - 0.5 * Math.pow(2 * (1 - v), 1.5);
              // Bump saturation: pull away from gray
              d[i + ch] = Math.max(0, Math.min(255, Math.round(v * 255)));
            }
          }
          ctx.putImageData(imgData, 0, 0);

          // --- Bottom half: green belly ---
          ctx.fillStyle = '#4A7A2E';
          ctx.fillRect(0, h, w, h);

          // --- Dividing line ---
          ctx.strokeStyle = '#2a5a10';
          ctx.lineWidth = Math.max(4, h / 60);
          ctx.beginPath();
          ctx.moveTo(0, h);
          ctx.lineTo(w, h);
          ctx.stroke();

          const tex = new THREE.CanvasTexture(c);
          tex.colorSpace = THREE.SRGBColorSpace;
          resolve(tex);
        };
        img.onerror = () => resolve(null);
        img.src = dataURI;
      });
    }

    // --- Angle helpers ---
    function normalizeAngle(a) {
      a = a % (Math.PI * 2);
      if (a > Math.PI) a -= Math.PI * 2;
      if (a < -Math.PI) a += Math.PI * 2;
      return a;
    }
    function lerpAngle(cur, tgt, t) {
      return cur + normalizeAngle(tgt - cur) * t;
    }

    // --- Create turtle from server data ---
    async function createTurtle3D(st) {
      const isHero = st.isHero || false;
      const scale = isHero ? 1.4 : 1.0;

      let shellMat;
      if (isHero) {
        const tex = createHeroTexture();
        shellMat = new THREE.MeshStandardMaterial({
          map: tex, color: 0xd4dd88,
          emissive: 0x3a2a00, emissiveIntensity: 0.35,
          roughness: 0.55, side: THREE.DoubleSide,
        });
      } else if (st.imageData) {
        const tex = await loadShellTexture(st.imageData);
        shellMat = new THREE.MeshStandardMaterial({
          map: tex || undefined,
          color: tex ? 0xffffff : 0xA8D5A2,
          emissive: tex ? 0x222222 : 0x000000,
          emissiveIntensity: tex ? 0.3 : 0,
          roughness: 0.55, side: THREE.DoubleSide,
        });
      } else {
        shellMat = new THREE.MeshStandardMaterial({
          color: 0xA8D5A2, roughness: 0.55, side: THREE.DoubleSide,
        });
      }

      const group = createTurtleGroup(shellMat);
      group.scale.set(scale, scale, scale);

      // Birthday cake on the hero turtle
      let flames = null;
      if (isHero) {
        const cakeData = createBirthdayCake();
        group.add(cakeData.cakeGroup);
        flames = cakeData.flames;
      }

      // Command indicator dot (red glow above shell)
      const indicatorMat = new THREE.MeshStandardMaterial({
        color: 0xff2222, emissive: 0xff0000, emissiveIntensity: 2,
        transparent: true, opacity: 0,
      });
      const indicator = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 8, 6), indicatorMat
      );
      indicator.position.set(0, 0.75, 0);
      indicator.visible = false;
      group.add(indicator);

      // Initial position & heading
      const dir = st.direction || 1;
      // direction 1 = moving right (+X), heading = -π/2
      // direction -1 = moving left (-X), heading = π/2
      const initHeading = dir > 0 ? -Math.PI / 2 : Math.PI / 2;
      const startX = dir > 0 ? TANK.xMin - 2 : TANK.xMax + 2;
      const startY = (Math.random() - 0.5) * 6;
      const startZ = (Math.random() - 0.5) * 8;
      group.position.set(startX, startY, startZ);
      group.rotation.order = 'YXZ';

      scene.add(group);

      // Map server speed (30-100) to 3D speed
      const mapped = 1.0 + ((st.speed - 30) / 70) * 2.5;
      const speed = isHero ? mapped * 0.65 : mapped;

      // Label
      const labelDiv = document.createElement('div');
      labelDiv.className = 'turtle-label';
      labelDiv.textContent = st.name || '';
      labelDiv.style.opacity = '0';
      labelsDiv.appendChild(labelDiv);

      const state = {
        id: st.id,
        name: st.name || '',
        isHero,
        speed,
        // Orientation
        heading: initHeading,
        swimPitch: 0,
        // Double-smoothed targets: raw → smooth → heading
        rawTargetH: initHeading,
        rawTargetP: 0,
        smoothTargetH: initHeading,
        smoothTargetP: 0,
        wanderHeading: initHeading,
        wanderPitch: 0,
        wanderTimer: 3 + Math.random() * 4,
        wanderInterval: 5 + Math.random() * 6,
        // Visual
        baseTilt: -0.42,   // nose down → shows back to camera
        phase: st.phase || Math.random() * Math.PI * 2,
        flipperFreq: 2.5 + speed * 0.8,
        bankAngle: 0,      // smoothed bank
        spinRemaining: 0,
        indicatorTimer: 0,
        cakeTimer: 0,
        comeCloserTimer: 0,
        // Name
        nameOpacity: 0,
        nameTimer: 0,
        namePhase: st.name ? 'fadein' : 'done',
      };

      return { group, state, labelDiv, shellMat, flames, indicator, indicatorMat };
    }

    // --- Movement ---
    function updateTurtleMovement(entry, dt, time) {
      const s = entry.state;
      const g = entry.group;
      const pos = g.position;

      // --- Wander: gradually drift toward new random directions ---
      s.wanderTimer -= dt;
      if (s.wanderTimer <= 0) {
        s.wanderTimer = s.wanderInterval;
        // Gentle heading change: ±50° from current
        s.wanderHeading = s.heading + (Math.random() - 0.5) * 1.75;
        // Gentle pitch: ±18°
        s.wanderPitch = (Math.random() - 0.5) * 0.6;
      }

      // --- Compute desired direction (wander + wall avoidance) ---
      let desX = -Math.sin(s.wanderHeading) * Math.cos(s.wanderPitch);
      let desY = Math.sin(s.wanderPitch);
      let desZ = -Math.cos(s.wanderHeading) * Math.cos(s.wanderPitch);

      // Wall avoidance: gentle repulsion that grows near walls
      const margin = 4;
      const force = 2.5;
      const nudge = (dist, limit) => {
        const t = Math.max(0, 1 - dist / limit);
        return t * t * force;
      };
      if (pos.x < TANK.xMin + margin) desX += nudge(pos.x - TANK.xMin, margin);
      if (pos.x > TANK.xMax - margin) desX -= nudge(TANK.xMax - pos.x, margin);
      if (pos.y < TANK.yMin + margin) desY += nudge(pos.y - TANK.yMin, margin);
      if (pos.y > TANK.yMax - margin) desY -= nudge(TANK.yMax - pos.y, margin);
      if (pos.z < TANK.zMin + margin) desZ += nudge(pos.z - TANK.zMin, margin);
      if (pos.z > TANK.zMax - margin) desZ -= nudge(TANK.zMax - pos.z, margin);

      // Raw target from desired direction (can jump)
      const hLen = Math.sqrt(desX * desX + desZ * desZ);
      s.rawTargetH = Math.atan2(-desX, -desZ);
      s.rawTargetP = Math.atan2(desY, Math.max(hLen, 0.01));
      s.rawTargetP = Math.max(-0.35, Math.min(0.35, s.rawTargetP));

      // Come-closer boost: snappier turning & movement when active
      const boostActive = s.comeCloserTimer > 0;
      if (boostActive) s.comeCloserTimer -= dt;

      // Double-smoothing: raw → smoothTarget → heading
      // Layer 1: smooth the target itself (absorbs jumps)
      const smoothRate = Math.min(1, dt * (boostActive ? 3.0 : 0.8));
      s.smoothTargetH = lerpAngle(s.smoothTargetH, s.rawTargetH, smoothRate);
      s.smoothTargetP += (s.rawTargetP - s.smoothTargetP) * smoothRate;

      // Layer 2: heading follows smoothed target
      const turnRate = Math.min(1, dt * (boostActive ? 5.0 : 1.2));
      s.heading = lerpAngle(s.heading, s.smoothTargetH, turnRate);
      s.swimPitch += (s.smoothTargetP - s.swimPitch) * turnRate;

      // --- Move forward along heading/pitch ---
      const cp = Math.cos(s.swimPitch);
      const dx = -Math.sin(s.heading) * cp;
      const dy = Math.sin(s.swimPitch);
      const dz = -Math.cos(s.heading) * cp;

      const moveSpeed = s.speed * (boostActive ? 2.0 : 1.0);
      pos.x += dx * moveSpeed * dt;
      pos.y += dy * moveSpeed * dt;
      pos.z += dz * moveSpeed * dt;

      // Gentle bob
      pos.y += Math.sin(time * 1.2 + s.phase) * 0.012;

      // Hard clamp (safety net)
      pos.x = Math.max(TANK.xMin, Math.min(TANK.xMax, pos.x));
      pos.y = Math.max(TANK.yMin, Math.min(TANK.yMax, pos.y));
      pos.z = Math.max(TANK.zMin, Math.min(TANK.zMax, pos.z));

      // --- Visual rotation (all smoothed) ---
      const swimWobble = Math.sin(time * 1.8 + s.phase) * 0.06;
      g.rotation.y = s.heading;
      g.rotation.x = s.baseTilt + s.swimPitch * 0.7 + swimWobble;

      // Smooth bank into turns
      const desiredBank = -normalizeAngle(s.smoothTargetH - s.heading) * 0.2;
      s.bankAngle += (desiredBank - s.bankAngle) * Math.min(1, dt * 2);
      g.rotation.z = s.bankAngle;

      // --- Barrel roll (spin command) ---
      if (s.spinRemaining > 0) {
        const spinSpeed = Math.PI * 2; // full rotation per second
        const spinStep = Math.min(s.spinRemaining, spinSpeed * dt);
        g.rotation.z += spinStep;
        s.spinRemaining -= spinStep;
      }

      // --- Flipper animation ---
      const ft = time * s.flipperFreq;
      for (const child of g.children) {
        switch (child.name) {
          case 'fl_fl': child.rotation.z =  Math.sin(ft) * 0.55; break;
          case 'fl_fr': child.rotation.z = -Math.sin(ft) * 0.55; break;
          case 'fl_bl': child.rotation.z =  Math.sin(ft * 0.7 + 1.5) * 0.2; break;
          case 'fl_br': child.rotation.z = -Math.sin(ft * 0.7 + 1.5) * 0.2; break;
        }
      }

      // --- Flame animation (hero cake) ---
      if (entry.flames) {
        for (const f of entry.flames) {
          const flicker = time * 8 + f.phase;
          // Outer flame: scale wobble + slight sway
          f.outer.scale.y = 0.85 + Math.sin(flicker) * 0.2 + Math.sin(flicker * 2.3) * 0.1;
          f.outer.scale.x = 0.9 + Math.sin(flicker * 1.7) * 0.15;
          f.outer.scale.z = 0.9 + Math.cos(flicker * 1.3) * 0.15;
          f.outer.position.x = f.inner.position.x + Math.sin(flicker * 1.1) * 0.008;
          // Inner flame: faster flicker
          f.inner.scale.y = 0.5 + Math.sin(flicker * 1.5) * 0.15;
          f.inner.scale.x = 0.4 + Math.sin(flicker * 2.1) * 0.1;
        }
      }

      // --- Command indicator pulse ---
      if (s.indicatorTimer > 0) {
        s.indicatorTimer -= dt;
        const pulse = 0.6 + 0.4 * Math.sin(s.indicatorTimer * 10);
        const fade = Math.min(1, s.indicatorTimer * 2); // fade out in last 0.5s
        entry.indicatorMat.opacity = pulse * fade;
        entry.indicator.visible = s.indicatorTimer > 0;
      }

      // --- Cake auto-remove timer ---
      if (s.cakeTimer > 0 && entry.flames) {
        s.cakeTimer -= dt;
        if (s.cakeTimer <= 0) {
          const existing = entry.group.getObjectByName('cake');
          if (existing) entry.group.remove(existing);
          entry.flames = null;
        }
      }

      // --- Name fade ---
      if (s.namePhase === 'fadein') {
        s.nameOpacity = Math.min(1, s.nameOpacity + dt);
        if (s.nameOpacity >= 1) { s.namePhase = 'visible'; s.nameTimer = 0; }
      } else if (s.namePhase === 'visible') {
        s.nameTimer += dt;
        if (s.nameTimer >= 30) s.namePhase = 'fadeout';
      } else if (s.namePhase === 'fadeout') {
        s.nameOpacity = Math.max(0, s.nameOpacity - dt);
        if (s.nameOpacity <= 0) s.namePhase = 'done';
      }
    }

    // --- Particles ---
    const PARTICLE_COUNT = 50;
    const pPos = new Float32Array(PARTICLE_COUNT * 3);
    (function initParticles() {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        pPos[i*3]   = (Math.random()-0.5) * (TANK.xMax-TANK.xMin);
        pPos[i*3+1] = (Math.random()-0.5) * (TANK.yMax-TANK.yMin);
        pPos[i*3+2] = (Math.random()-0.5) * (TANK.zMax-TANK.zMin);
      }
    })();
    const pGeo = new THREE.BufferGeometry();
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    scene.add(new THREE.Points(pGeo, new THREE.PointsMaterial({
      color: 0xddeeff, size: 0.10, transparent: true, opacity: 0.6, sizeAttenuation: true,
    })));

    function updateParticles(dt) {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        pPos[i*3+1] += dt * 0.35;
        pPos[i*3]   += Math.sin(i*1.7 + performance.now()*0.001) * 0.002;
        if (pPos[i*3+1] > TANK.yMax) {
          pPos[i*3+1] = TANK.yMin;
          pPos[i*3]   = (Math.random()-0.5) * (TANK.xMax-TANK.xMin);
          pPos[i*3+2] = (Math.random()-0.5) * (TANK.zMax-TANK.zMin);
        }
      }
      pGeo.attributes.position.needsUpdate = true;
    }

    // --- Ground (flat ocean floor, fades into ocean toward the back) ---
    (function createGround() {
      const W = 512, H = 256;
      const gc = document.createElement('canvas');
      gc.width = W; gc.height = H;
      const gx = gc.getContext('2d');

      // Linear gradient: solid sandy near camera (bottom of texture = +Z),
      // fading to transparent further away (top of texture = -Z)
      const sg = gx.createLinearGradient(0, 0, 0, H);
      sg.addColorStop(0, 'rgba(50, 40, 28, 0)');       // far edge — transparent
      sg.addColorStop(0.15, 'rgba(60, 48, 32, 0.15)');
      sg.addColorStop(0.35, 'rgba(72, 58, 40, 0.55)');
      sg.addColorStop(0.55, 'rgba(82, 66, 45, 0.85)');
      sg.addColorStop(0.75, 'rgba(88, 70, 48, 0.95)');
      sg.addColorStop(1, 'rgba(90, 72, 50, 1)');        // near edge — solid
      gx.fillStyle = sg;
      gx.fillRect(0, 0, W, H);

      // Sand grain speckle
      for (let i = 0; i < 1400; i++) {
        const px = Math.random() * W, py = Math.random() * H;
        const fade = py / H; // 0 at top (far), 1 at bottom (near)
        if (fade < 0.2) continue;
        const shade = 65 + Math.random() * 45;
        const a = (0.25 + Math.random() * 0.15) * fade;
        gx.fillStyle = `rgba(${shade+25}, ${shade+8}, ${shade-12}, ${a})`;
        gx.fillRect(px, py, 1 + Math.random() * 2, 1 + Math.random() * 2);
      }

      // Ripple lines
      gx.lineWidth = 1.5;
      for (let i = 0; i < 6; i++) {
        const y = H * 0.3 + i * (H * 0.11) + Math.random() * 10;
        const fade = y / H;
        gx.strokeStyle = `rgba(105, 85, 58, ${(0.08 + Math.random() * 0.06) * fade})`;
        gx.beginPath();
        gx.moveTo(0, y);
        for (let px = 0; px <= W; px += 30) {
          gx.lineTo(px, y + Math.sin(px * 0.025 + i) * 5);
        }
        gx.stroke();
      }

      // Pebbles
      for (let i = 0; i < 20; i++) {
        const px = Math.random() * W;
        const py = H * 0.35 + Math.random() * H * 0.6;
        const fade = py / H;
        const r = 2 + Math.random() * 3;
        gx.fillStyle = `rgba(${60+Math.random()*35}, ${50+Math.random()*28}, ${38+Math.random()*18}, ${0.4 * fade})`;
        gx.beginPath();
        gx.ellipse(px, py, r, r * 0.7, Math.random() * Math.PI, 0, Math.PI * 2);
        gx.fill();
      }

      const groundTex = new THREE.CanvasTexture(gc);
      groundTex.colorSpace = THREE.SRGBColorSpace;

      // Wide flat plane: stretches beyond screen edges horizontally,
      // extends well toward the camera so no black gap at screen bottom
      const groundGeo = new THREE.PlaneGeometry(60, 28);
      const groundMat = new THREE.MeshStandardMaterial({
        map: groundTex, roughness: 0.95,
        transparent: true, depthWrite: false,
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.set(0, TANK.yMin - 0.05, 10);
      scene.add(ground);

      // A few scattered rocks on the ground
      const rockGeo = new THREE.SphereGeometry(1, 8, 6);
      const rockMat = new THREE.MeshStandardMaterial({ color: 0x6B6058, roughness: 0.95 });
      const rockMat2 = new THREE.MeshStandardMaterial({ color: 0x7A7060, roughness: 0.95 });
      const rocks = [
        { x: -6, z: 2, sx: 0.5, sy: 0.25, sz: 0.4 },
        { x: 8, z: 0, sx: 0.7, sy: 0.3, sz: 0.5 },
        { x: -12, z: 1, sx: 0.4, sy: 0.2, sz: 0.35 },
        { x: 3, z: 5, sx: 0.35, sy: 0.18, sz: 0.3 },
        { x: 12, z: 4, sx: 0.55, sy: 0.22, sz: 0.45 },
        { x: -9, z: 6, sx: 0.3, sy: 0.15, sz: 0.25 },
      ];
      for (const r of rocks) {
        const m = new THREE.Mesh(rockGeo, Math.random() > 0.5 ? rockMat : rockMat2);
        m.scale.set(r.sx, r.sy, r.sz);
        m.position.set(r.x, TANK.yMin + r.sy * 0.4, r.z);
        m.rotation.y = Math.random() * Math.PI;
        scene.add(m);
      }
    })();

    // --- Coral ---
    function createCoral(cx, cz, height, color, branchCount) {
      const group = new THREE.Group();
      group.position.set(cx, TANK.yMin, cz);
      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.8, emissive: color, emissiveIntensity: 0.1 });
      const lighterColor = new THREE.Color(color).lerp(new THREE.Color(0xffffff), 0.3);
      const tipMat = new THREE.MeshStandardMaterial({ color: lighterColor, roughness: 0.75, emissive: lighterColor, emissiveIntensity: 0.08 });

      // Thick base mound
      const baseGeo = new THREE.SphereGeometry(0.25, 8, 6);
      const base = new THREE.Mesh(baseGeo, mat);
      base.scale.set(1, 0.4, 1);
      base.position.y = 0.08;
      group.add(base);

      // Main trunk — tapered cylinder
      const trunkGeo = new THREE.CylinderGeometry(0.06, 0.14, height, 8);
      const trunk = new THREE.Mesh(trunkGeo, mat);
      trunk.position.y = height / 2 + 0.1;
      group.add(trunk);

      // Branches with sub-branches for a tree-like coral look
      for (let i = 0; i < branchCount; i++) {
        const angle = (i / branchCount) * Math.PI * 2 + Math.random() * 0.6;
        const bh = height * (0.25 + Math.random() * 0.4);
        const by = height * (0.25 + Math.random() * 0.5);
        const bGeo = new THREE.CylinderGeometry(0.03, 0.07, bh, 6);
        const branch = new THREE.Mesh(bGeo, mat);
        const bx = Math.cos(angle) * (0.15 + Math.random() * 0.1);
        const bz = Math.sin(angle) * (0.15 + Math.random() * 0.1);
        branch.position.set(bx, by + bh * 0.3, bz);
        branch.rotation.z = Math.cos(angle) * (0.35 + Math.random() * 0.3);
        branch.rotation.x = Math.sin(angle) * (0.35 + Math.random() * 0.3);
        group.add(branch);

        // Bulbous tip
        const tipR = 0.07 + Math.random() * 0.08;
        const tipGeo = new THREE.SphereGeometry(tipR, 8, 6);
        const tip = new THREE.Mesh(tipGeo, tipMat);
        tip.position.set(
          bx + Math.cos(angle) * (bh * 0.35),
          by + bh * 0.75,
          bz + Math.sin(angle) * (bh * 0.35)
        );
        group.add(tip);

        // Sub-branch
        if (Math.random() > 0.4) {
          const sbh = bh * 0.5;
          const sbGeo = new THREE.CylinderGeometry(0.02, 0.04, sbh, 5);
          const sub = new THREE.Mesh(sbGeo, mat);
          const sa = angle + (Math.random() - 0.5) * 1.2;
          sub.position.set(bx * 0.8, by + bh * 0.4, bz * 0.8);
          sub.rotation.z = Math.cos(sa) * 0.6;
          sub.rotation.x = Math.sin(sa) * 0.6;
          group.add(sub);
          const stGeo = new THREE.SphereGeometry(0.05, 6, 4);
          const st = new THREE.Mesh(stGeo, tipMat);
          st.position.set(
            sub.position.x + Math.cos(sa) * sbh * 0.3,
            by + bh * 0.6,
            sub.position.z + Math.sin(sa) * sbh * 0.3
          );
          group.add(st);
        }
      }

      scene.add(group);
      return group;
    }

    // Coral placements
    const coralData = [
      { x: -10, z: 0, h: 1.8, c: 0xE85D75, b: 5 },
      { x: -6, z:  5, h: 1.4, c: 0xF4A460, b: 4 },
      { x:  9, z:  1, h: 2.0, c: 0xD94070, b: 5 },
      { x: 11, z:  4, h: 1.5, c: 0xE8734A, b: 4 },
      { x: -3, z:  6, h: 1.1, c: 0xC85080, b: 3 },
      { x:  5, z: -1, h: 1.7, c: 0xF09868, b: 4 },
      { x:  0, z:  7, h: 1.3, c: 0xDA6888, b: 3 },
      { x: -12, z:  3, h: 1.0, c: 0xE0A070, b: 3 },
      { x:  13, z:  0, h: 1.2, c: 0xCC5568, b: 4 },
    ];
    for (const cd of coralData) {
      createCoral(cd.x, cd.z, cd.h, cd.c, cd.b);
    }

    // --- Seaweed (segmented, curving kelp blades) ---
    const seaweedPieces = [];
    const seaweedColors = [0x2D7A2D, 0x3A8A3A, 0x358535, 0x4A9A3A];

    function createKelpBlade(bx, bz) {
      const segments = 5 + Math.floor(Math.random() * 4);
      const segH = 0.45 + Math.random() * 0.2;
      const group = new THREE.Group();
      group.position.set(bx, TANK.yMin, bz);

      const color = seaweedColors[Math.floor(Math.random() * seaweedColors.length)];
      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.75, side: THREE.DoubleSide });

      let prevPivot = group;
      const pivots = [];
      for (let i = 0; i < segments; i++) {
        const pivot = new THREE.Group();
        pivot.position.y = i === 0 ? 0.1 : segH;

        // Each segment is a tapered plane
        const w = 0.18 - i * 0.012;
        const geo = new THREE.PlaneGeometry(Math.max(w, 0.05), segH, 1, 1);
        // Shift geometry so it pivots from the bottom
        const posAttr = geo.attributes.position;
        for (let v = 0; v < posAttr.count; v++) {
          posAttr.setY(v, posAttr.getY(v) + segH / 2);
        }
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.y = (Math.random() - 0.5) * 0.3;
        pivot.add(mesh);

        prevPivot.add(pivot);
        pivots.push(pivot);
        prevPivot = pivot;
      }

      scene.add(group);
      return {
        group,
        pivots,
        phase: Math.random() * Math.PI * 2,
        freq: 0.6 + Math.random() * 0.4,
        amp: 0.06 + Math.random() * 0.04,
      };
    }

    const kelpPositions = [
      { x: -7, z: 2 }, { x: 6, z: 6 }, { x: -11, z: 1 },
      { x: 3, z: 0 }, { x: 10, z: 3 }, { x: -4, z: -1 },
      { x: 13, z: 2 }, { x: -13, z: 5 }, { x: -1, z: 4 },
      { x: 5, z: 7 },
    ];
    for (const kp of kelpPositions) {
      const count = 2 + Math.floor(Math.random() * 3);
      for (let i = 0; i < count; i++) {
        seaweedPieces.push(createKelpBlade(
          kp.x + (Math.random() - 0.5) * 0.6,
          kp.z + (Math.random() - 0.5) * 0.6
        ));
      }
    }

    function updateSeaweed(time) {
      for (const sw of seaweedPieces) {
        for (let i = 0; i < sw.pivots.length; i++) {
          // Each segment sways with increasing amplitude up the chain
          const t = time * sw.freq + sw.phase + i * 0.5;
          sw.pivots[i].rotation.z = Math.sin(t) * sw.amp * (1 + i * 0.3);
          sw.pivots[i].rotation.x = Math.sin(t * 0.7 + 1) * sw.amp * 0.3;
        }
      }
    }

    // --- Fish (proper shaped tropical fish) ---
    const FISH_COUNT = 8;
    const fishList = [];

    // Fish body: ellipsoid (flattened sphere)
    const fishBodyGeo = new THREE.SphereGeometry(1, 10, 8);
    // Tail: two triangle fins forming a forked tail
    const fishTailGeo = new THREE.BufferGeometry();
    const tv = new Float32Array([
      0,0,0,  0.22,0.18,0,  0.08,0,0,
      0,0,0,  0.08,0,0,     0.22,-0.18,0,
    ]);
    fishTailGeo.setAttribute('position', new THREE.BufferAttribute(tv, 3));
    fishTailGeo.computeVertexNormals();
    // Dorsal fin
    const dorsalGeo = new THREE.BufferGeometry();
    const dv = new Float32Array([
      -0.08,0,0,  0.08,0,0,  0,0.14,0,
    ]);
    dorsalGeo.setAttribute('position', new THREE.BufferAttribute(dv, 3));
    dorsalGeo.computeVertexNormals();
    // Pectoral fin (small side fin)
    const pectoralGeo = new THREE.BufferGeometry();
    const pv = new Float32Array([
      0,0,0,  0.12,-0.06,0.04,  0.02,-0.08,0,
    ]);
    pectoralGeo.setAttribute('position', new THREE.BufferAttribute(pv, 3));
    pectoralGeo.computeVertexNormals();

    const fishPalette = [
      { body: 0x3388CC, accent: 0x55BBEE },  // blue
      { body: 0xDD8833, accent: 0xFFBB55 },  // orange clown
      { body: 0xCC3355, accent: 0xEE6688 },  // red
      { body: 0x33BB88, accent: 0x66DDAA },  // teal
      { body: 0xDDCC33, accent: 0xEEDD66 },  // yellow
      { body: 0x8844BB, accent: 0xAA77DD },  // purple
      { body: 0x33BBBB, accent: 0x66DDDD },  // cyan
      { body: 0xDD6633, accent: 0xFF9966 },  // coral
    ];

    for (let i = 0; i < FISH_COUNT; i++) {
      const pal = fishPalette[i % fishPalette.length];
      const bodyMat = new THREE.MeshStandardMaterial({ color: pal.body, roughness: 0.35, metalness: 0.15, emissive: pal.body, emissiveIntensity: 0.1 });
      const accentMat = new THREE.MeshStandardMaterial({ color: pal.accent, roughness: 0.35, side: THREE.DoubleSide, emissive: pal.accent, emissiveIntensity: 0.08 });
      const finMat = new THREE.MeshStandardMaterial({ color: pal.accent, roughness: 0.45, side: THREE.DoubleSide, transparent: true, opacity: 0.85 });

      const group = new THREE.Group();
      const sz = 0.5 + Math.random() * 0.3; // vary size

      // Body (flattened ellipsoid — wider than tall, longer front to back)
      const body = new THREE.Mesh(fishBodyGeo, bodyMat);
      body.scale.set(0.12 * sz, 0.16 * sz, 0.28 * sz);
      group.add(body);

      // Lighter belly
      const belly = new THREE.Mesh(fishBodyGeo, accentMat);
      belly.scale.set(0.10 * sz, 0.10 * sz, 0.22 * sz);
      belly.position.y = -0.02 * sz;
      group.add(belly);

      // Eyes (both sides)
      for (const side of [-1, 1]) {
        const eye = new THREE.Mesh(eyeGeo, eyeWhiteMat);
        eye.position.set(side * 0.06 * sz, 0.03 * sz, -0.22 * sz);
        eye.scale.setScalar(0.6 * sz);
        group.add(eye);
        const pupil = new THREE.Mesh(pupilGeo, pupilMat);
        pupil.position.set(side * 0.065 * sz, 0.03 * sz, -0.24 * sz);
        pupil.scale.setScalar(0.6 * sz);
        group.add(pupil);
      }

      // Tail fin (forked)
      const tail = new THREE.Mesh(fishTailGeo, finMat);
      tail.position.z = 0.25 * sz;
      tail.scale.setScalar(sz);
      tail.name = 'fishtail';
      group.add(tail);

      // Dorsal fin (top)
      const dorsal = new THREE.Mesh(dorsalGeo, finMat);
      dorsal.position.set(0, 0.14 * sz, 0);
      dorsal.scale.setScalar(sz);
      group.add(dorsal);

      // Pectoral fins (side fins)
      for (const side of [-1, 1]) {
        const pec = new THREE.Mesh(pectoralGeo, finMat);
        pec.position.set(side * 0.10 * sz, -0.04 * sz, -0.08 * sz);
        pec.scale.set(side * sz, sz, sz);
        pec.name = 'pectoral';
        group.add(pec);
      }

      const heading = Math.random() * Math.PI * 2;
      group.position.set(
        (Math.random() - 0.5) * (TANK.xMax - TANK.xMin) * 0.8,
        TANK.yMin + 1.5 + Math.random() * (TANK.yMax - TANK.yMin - 3),
        (Math.random() - 0.5) * (TANK.zMax - TANK.zMin) * 0.8
      );
      group.rotation.order = 'YXZ';

      scene.add(group);

      fishList.push({
        group,
        speed: 1.5 + Math.random() * 2.5,
        heading,
        targetHeading: heading,
        pitch: 0,
        targetPitch: 0,
        wanderTimer: Math.random() * 3,
        phase: Math.random() * Math.PI * 2,
      });
    }

    function updateFish(dt, time) {
      for (const f of fishList) {
        f.wanderTimer -= dt;
        if (f.wanderTimer <= 0) {
          f.wanderTimer = 2 + Math.random() * 3;
          f.targetHeading = f.heading + (Math.random() - 0.5) * 2.0;
          f.targetPitch = (Math.random() - 0.5) * 0.5;
        }

        const pos = f.group.position;
        let desX = -Math.sin(f.targetHeading);
        let desY = Math.sin(f.targetPitch);
        let desZ = -Math.cos(f.targetHeading);
        const margin = 3, force = 3;
        const nudge = (d, m) => { const t = Math.max(0, 1 - d / m); return t * t * force; };
        if (pos.x < TANK.xMin + margin) desX += nudge(pos.x - TANK.xMin, margin);
        if (pos.x > TANK.xMax - margin) desX -= nudge(TANK.xMax - pos.x, margin);
        if (pos.y < TANK.yMin + 1.5 + margin) desY += nudge(pos.y - TANK.yMin - 1.5, margin);
        if (pos.y > TANK.yMax - margin) desY -= nudge(TANK.yMax - pos.y, margin);
        if (pos.z < TANK.zMin + margin) desZ += nudge(pos.z - TANK.zMin, margin);
        if (pos.z > TANK.zMax - margin) desZ -= nudge(TANK.zMax - pos.z, margin);

        const hLen = Math.sqrt(desX * desX + desZ * desZ);
        const rawH = Math.atan2(-desX, -desZ);
        const rawP = Math.atan2(desY, Math.max(hLen, 0.01));

        f.heading = lerpAngle(f.heading, rawH, Math.min(1, dt * 2.5));
        f.pitch += (Math.max(-0.4, Math.min(0.4, rawP)) - f.pitch) * Math.min(1, dt * 2.5);

        const cp = Math.cos(f.pitch);
        pos.x += -Math.sin(f.heading) * cp * f.speed * dt;
        pos.y += Math.sin(f.pitch) * f.speed * dt;
        pos.z += -Math.cos(f.heading) * cp * f.speed * dt;

        pos.x = Math.max(TANK.xMin, Math.min(TANK.xMax, pos.x));
        pos.y = Math.max(TANK.yMin + 1, Math.min(TANK.yMax, pos.y));
        pos.z = Math.max(TANK.zMin, Math.min(TANK.zMax, pos.z));

        f.group.rotation.y = f.heading;
        f.group.rotation.x = f.pitch;
        f.group.rotation.z = -normalizeAngle(rawH - f.heading) * 0.3;

        // Tail wag + pectoral fin flutter
        const wag = Math.sin(time * 12 + f.phase);
        for (const child of f.group.children) {
          if (child.name === 'fishtail') child.rotation.y = wag * 0.45;
          if (child.name === 'pectoral') child.rotation.z = Math.sin(time * 8 + f.phase) * 0.3;
        }
      }
    }

    // --- Projection helper ---
    const _v = new THREE.Vector3();
    function projectToScreen(position) {
      _v.copy(position).project(camera);
      return {
        x: ( _v.x * 0.5 + 0.5) * innerWidth,
        y: (-_v.y * 0.5 + 0.5) * innerHeight,
      };
    }

    // --- Labels ---
    function updateLabels() {
      for (const e of turtleMap.values()) {
        const div = e.labelDiv;
        if (e.state.nameOpacity > 0 && e.state.name) {
          const p = projectToScreen(e.group.position);
          div.style.left = p.x + 'px';
          div.style.top = (p.y - 35) + 'px';
          div.style.opacity = String(e.state.nameOpacity);
        } else {
          div.style.opacity = '0';
        }
      }
    }

    function updateTitle() {
      const hero = turtleMap.get('hero');
      if (!hero) { titleLabel.style.opacity = '0'; return; }
      titleLabel.style.opacity = String(titleOpacity);
      const p = projectToScreen(hero.group.position);
      titleLabel.style.left = p.x + 'px';
      titleLabel.style.top = Math.max(40, p.y - 160) + 'px';
      titleLabel.style.fontSize = Math.min(48, innerWidth / 10) + 'px';
    }

    // --- Command handlers ---
    function handleCommand(entry, command) {
      const s = entry.state;
      s.indicatorTimer = 2.5; // flash red dot for all commands

      switch (command) {
        case 'come_closer': {
          // Aim at front-center of tank (within wall-safe zone)
          const targetX = 0, targetY = 0, targetZ = TANK.zMax - 6;
          const dx = targetX - entry.group.position.x;
          const dy = targetY - entry.group.position.y;
          const dz = targetZ - entry.group.position.z;
          const hLen = Math.sqrt(dx * dx + dz * dz);
          s.wanderHeading = Math.atan2(-dx, -dz);
          s.wanderPitch = Math.atan2(dy, Math.max(hLen, 0.01));
          s.wanderPitch = Math.max(-0.35, Math.min(0.35, s.wanderPitch));
          s.wanderTimer = 12;
          s.wanderInterval = s.wanderTimer;
          s.comeCloserTimer = 6; // boost speed & responsiveness for 6s
          break;
        }

        case 'birthday_cake':
          // Add cake (or refresh timer if already present)
          if (!entry.flames) {
            const cakeData = createBirthdayCake();
            entry.group.add(cakeData.cakeGroup);
            entry.flames = cakeData.flames;
          }
          s.cakeTimer = 10; // auto-remove after 10 seconds
          break;

        case 'spin':
          // Trigger a dramatic barrel roll (2 full rotations)
          s.spinRemaining = (s.spinRemaining || 0) + Math.PI * 4;
          break;
      }
    }

    // --- Polling ---
    async function pollTurtles() {
      try {
        const knownIds = Array.from(turtleMap.keys()).join(',');
        const res = await fetch(`/api/turtles?eventCode=${encodeURIComponent(eventCode)}&knownIds=${encodeURIComponent(knownIds)}`);
        if (!res.ok) return;
        const data = await res.json();
        const serverIds = new Set();

        for (const st of data.turtles) {
          try {
            serverIds.add(st.id);
            let e;
            if (turtleMap.has(st.id)) {
              e = turtleMap.get(st.id);
              e.state.name = st.name;
              e.labelDiv.textContent = st.name || '';
            } else {
              e = await createTurtle3D(st);
              turtleMap.set(st.id, e);
            }
            // Handle commands (deduplicate with SSE delivery)
            if (st.command) {
              if (!st.commandId || !processedCommands.has(st.commandId)) {
                if (st.commandId) processedCommands.add(st.commandId);
                handleCommand(e, st.command);
              }
            }
          } catch (err) {
            console.error('Error processing turtle:', st.id, err);
          }
        }

        for (const [id, e] of turtleMap) {
          if (!serverIds.has(id)) {
            scene.remove(e.group);
            e.labelDiv.remove();
            if (e.shellMat) {
              if (e.shellMat.map) e.shellMat.map.dispose();
              e.shellMat.dispose();
            }
            turtleMap.delete(id);
          }
        }
      } catch {}
    }

    // --- SSE for instant command delivery ---
    function connectSSE() {
      const es = new EventSource(`/api/events?eventCode=${encodeURIComponent(eventCode)}`);
      es.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (processedCommands.has(data.commandId)) return;
          processedCommands.add(data.commandId);
          // Prevent unbounded growth
          if (processedCommands.size > 200) {
            const arr = Array.from(processedCommands);
            for (let i = 0; i < 100; i++) processedCommands.delete(arr[i]);
          }
          const entry = turtleMap.get(data.turtleId);
          if (entry) handleCommand(entry, data.command);
        } catch {}
      };
      return es;
    }

    function startPolling() {
      pollTurtles();
      pollTimer = setInterval(pollTurtles, 3000);
      connectSSE();
    }

    // --- Animation loop ---
    let lastFrame = performance.now();

    function animate(now) {
      if (!aquariumRunning) return;
      requestAnimationFrame(animate);

      const dt = Math.min((now - lastFrame) / 1000, 0.1);
      lastFrame = now;
      const time = (now / 1000) - startTime;

      if (titleOpacity < 1) titleOpacity = Math.min(1, titleOpacity + dt * 0.5);

      for (const e of turtleMap.values()) updateTurtleMovement(e, dt, time);
      updateFish(dt, time);
      updateSeaweed(time);
      updateParticles(dt);
      updateLabels();
      updateTitle();
      renderer.render(scene, camera);
    }

    // --- Code entry ---
    async function validateCode(code) {
      try { return (await fetch(`/api/turtles?eventCode=${encodeURIComponent(code)}&knownIds=`)).status; }
      catch { return 0; }
    }

    async function handleCodeSubmit() {
      const code = codeInput.value.trim();
      if (!code) return;
      codeError.textContent = '';
      codeSubmit.disabled = true;
      codeSubmit.textContent = 'Checking...';
      const status = await validateCode(code);
      if (status === 200) {
        eventCode = code;
        localStorage.setItem('turtleCode', code);
        overlay.classList.add('hidden');
        startAquarium();
      } else if (status === 429) {
        codeError.textContent = 'Too many attempts. Wait a moment.';
      } else if (status === 403) {
        codeError.textContent = 'Wrong code. Try again!';
      } else {
        codeError.textContent = 'Connection error. Try again.';
      }
      codeSubmit.disabled = false;
      codeSubmit.textContent = 'Enter';
    }

    codeSubmit.addEventListener('click', handleCodeSubmit);
    codeInput.addEventListener('keydown', e => { if (e.key === 'Enter') handleCodeSubmit(); });

    function startAquarium() {
      aquariumRunning = true;
      startTime = performance.now() / 1000;
      lastFrame = performance.now();
      startPolling();
      requestAnimationFrame(animate);
    }

    // --- Init ---
    (async () => {
      const stored = localStorage.getItem('turtleCode');
      if (stored) {
        const status = await validateCode(stored);
        if (status === 200) {
          eventCode = stored;
          overlay.classList.add('hidden');
          startAquarium();
          return;
        }
      }
      codeInput.focus();
    })();
  </script>
</body>
</html>

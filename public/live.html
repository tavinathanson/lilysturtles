<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Lily's Turtles</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: #041526;
    }
    #container {
      width: 100%; height: 100%;
    }
    #container canvas {
      display: block;
    }
    #labels {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 1;
    }
    .turtle-label {
      position: absolute;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-weight: bold;
      font-size: 14px;
      text-shadow: 0 1px 4px rgba(0,0,0,0.7);
      transform: translate(-50%, -100%);
      white-space: nowrap;
      transition: opacity 0.05s linear;
    }
    #title-label {
      position: absolute;
      color: white;
      font-family: 'Nunito', sans-serif;
      font-weight: 800;
      font-size: 48px;
      text-shadow: 0 0 15px rgba(255,255,255,0.5), 0 0 30px rgba(255,255,255,0.2);
      transform: translate(-50%, -100%);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.05s linear;
      pointer-events: none;
    }
    #overlay {
      position: fixed;
      inset: 0;
      background: rgba(4, 21, 38, 0.92);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #overlay.hidden { display: none; }
    .code-box {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 36px 32px;
      max-width: 360px;
      width: 90%;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    .code-box h1 {
      font-family: 'Nunito', sans-serif;
      color: #0a4d6e;
      font-size: 26px;
      margin-bottom: 8px;
    }
    .code-box p {
      color: #666;
      font-size: 15px;
      margin-bottom: 20px;
    }
    .code-box input {
      width: 100%;
      padding: 14px;
      border: 2px solid #ddd;
      border-radius: 12px;
      font-size: 20px;
      text-align: center;
      letter-spacing: 8px;
      margin-bottom: 16px;
      -webkit-appearance: none;
    }
    .code-box input:focus {
      outline: none;
      border-color: #14a3c7;
    }
    .code-box button {
      width: 100%;
      padding: 14px;
      background: #0d7fa5;
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 17px;
      font-weight: 600;
      cursor: pointer;
      min-height: 48px;
    }
    .code-box button:active { background: #0a6a8a; }
    .code-box .error {
      color: #c00;
      font-size: 14px;
      margin-top: 12px;
      min-height: 20px;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="labels">
    <div id="title-label">Lily's Turtles</div>
  </div>

  <div id="overlay">
    <div class="code-box">
      <h1>Lily's Turtles</h1>
      <p>Enter the Turtle Code</p>
      <input type="text" id="codeInput" inputmode="numeric" pattern="\d*" maxlength="10" autocomplete="off">
      <button id="codeSubmit">Enter</button>
      <div class="error" id="codeError"></div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // --- DOM refs ---
    const container = document.getElementById('container');
    const labelsDiv = document.getElementById('labels');
    const titleLabel = document.getElementById('title-label');
    const overlay = document.getElementById('overlay');
    const codeInput = document.getElementById('codeInput');
    const codeSubmit = document.getElementById('codeSubmit');
    const codeError = document.getElementById('codeError');

    // --- State ---
    let eventCode = '';
    let turtleMap = new Map(); // id -> { group, state, labelDiv }
    let aquariumRunning = false;
    let pollTimer = null;
    let titleOpacity = 0;
    let startTime = 0;

    // --- Tank boundaries ---
    const TANK = {
      xMin: -12, xMax: 12,
      yMin: -5, yMax: 5,
      zMin: -6, zMax: 6
    };

    // --- Three.js Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x041526);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 4, 20);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Subtle blue fill from above for underwater feel
    const fillLight = new THREE.DirectionalLight(0x4488cc, 0.3);
    fillLight.position.set(0, 10, 0);
    scene.add(fillLight);

    // --- Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Shared Geometry (created once) ---
    const shellGeo = new THREE.SphereGeometry(1, 24, 16);
    const headGeo = new THREE.SphereGeometry(0.3, 12, 8);
    const flipperGeo = new THREE.BoxGeometry(0.5, 0.08, 0.3);
    const tailGeo = new THREE.BoxGeometry(0.15, 0.06, 0.3);
    const greenMat = new THREE.MeshStandardMaterial({ color: 0x7A9A3A });

    // --- Turtle Geometry Factory ---
    function createTurtleGroup(shellMaterial) {
      const group = new THREE.Group();

      // Shell
      const shell = new THREE.Mesh(shellGeo, shellMaterial);
      shell.scale.set(1.0, 0.5, 0.8);
      group.add(shell);

      // Head
      const head = new THREE.Mesh(headGeo, greenMat);
      head.position.set(0, 0.05, -0.9);
      group.add(head);

      // Flippers — each in a pivot group for rotation animation
      const flipperPositions = [
        { x: -0.6, z: -0.4, ry: -0.3, name: 'fl_front_left' },
        { x:  0.6, z: -0.4, ry:  0.3, name: 'fl_front_right' },
        { x: -0.55, z:  0.4, ry:  0.3, name: 'fl_back_left' },
        { x:  0.55, z:  0.4, ry: -0.3, name: 'fl_back_right' },
      ];

      for (const fp of flipperPositions) {
        const pivot = new THREE.Group();
        pivot.position.set(fp.x, -0.1, fp.z);
        pivot.rotation.y = fp.ry;
        pivot.name = fp.name;

        const flipper = new THREE.Mesh(flipperGeo, greenMat);
        // Offset so it rotates from attachment point
        flipper.position.set(fp.x > 0 ? 0.2 : -0.2, 0, 0);
        pivot.add(flipper);
        group.add(pivot);
      }

      // Tail
      const tail = new THREE.Mesh(tailGeo, greenMat);
      tail.position.set(0, -0.05, 0.85);
      group.add(tail);

      return group;
    }

    // --- Texture from image data URI ---
    function loadTextureFromDataURI(dataURI) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          const texture = new THREE.CanvasTexture(canvas);
          texture.colorSpace = THREE.SRGBColorSpace;
          resolve(texture);
        };
        img.onerror = () => {
          resolve(null);
        };
        img.src = dataURI;
      });
    }

    // --- Create 3D turtle from server data ---
    async function createTurtle3D(serverTurtle) {
      const isHero = serverTurtle.isHero || false;
      const scale = isHero ? 1.4 : 1.0;

      let shellMaterial;

      if (serverTurtle.imageData) {
        const texture = await loadTextureFromDataURI(serverTurtle.imageData);
        if (texture) {
          if (isHero) {
            shellMaterial = new THREE.MeshStandardMaterial({
              map: texture,
              color: 0xB8CC58,
              emissive: 0x2a1f00,
              emissiveIntensity: 0.3,
              side: THREE.DoubleSide,
            });
          } else {
            shellMaterial = new THREE.MeshStandardMaterial({
              map: texture,
              side: THREE.DoubleSide,
            });
          }
        } else {
          shellMaterial = new THREE.MeshStandardMaterial({
            color: isHero ? 0xB8CC58 : 0x55aa55,
            side: THREE.DoubleSide,
          });
        }
      } else {
        shellMaterial = new THREE.MeshStandardMaterial({
          color: isHero ? 0xB8CC58 : 0x55aa55,
          side: THREE.DoubleSide,
        });
      }

      const group = createTurtleGroup(shellMaterial);
      group.scale.set(scale, scale, scale);

      // Base orientation: tilt forward so shell top faces camera
      group.rotation.x = -1.22; // ~-70 degrees

      // Starting position
      const dir = serverTurtle.direction || 1;
      const startX = dir > 0 ? TANK.xMin - 2 : TANK.xMax + 2;
      const startY = (Math.random() - 0.5) * (TANK.yMax - TANK.yMin) * 0.6;
      const startZ = (Math.random() - 0.5) * (TANK.zMax - TANK.zMin) * 0.6;
      group.position.set(startX, startY, startZ);

      scene.add(group);

      // Map server speed (30-100) to 3D speed (~0.5-2.0)
      const mappedSpeed = 0.5 + ((serverTurtle.speed - 30) / 70) * 1.5;
      const speed = isHero ? mappedSpeed * 0.6 : mappedSpeed;

      // Create label div
      const labelDiv = document.createElement('div');
      labelDiv.className = 'turtle-label';
      labelDiv.textContent = serverTurtle.name || '';
      labelDiv.style.opacity = '0';
      labelsDiv.appendChild(labelDiv);

      const state = {
        id: serverTurtle.id,
        name: serverTurtle.name || '',
        isHero: isHero,
        // Velocity
        vx: speed * dir,
        vy: (Math.random() - 0.5) * 0.3,
        vz: (Math.random() - 0.5) * 0.3,
        // Bob
        phase: serverTurtle.phase || Math.random() * Math.PI * 2,
        amplitude: isHero ? 0.03 : 0.03,
        // Rotation
        baseRotX: -1.22,
        currentRotY: 0,
        targetRotY: 0,
        // Flipper speed
        flipperFreq: 3 + speed * 1.5,
        // Name fade
        nameOpacity: 0,
        nameTimer: 0,
        namePhase: serverTurtle.name ? 'fadein' : 'done',
      };

      return { group, state, labelDiv, shellMaterial };
    }

    // --- Particles (bubble points) ---
    const PARTICLE_COUNT = 50;
    const particlePositions = new Float32Array(PARTICLE_COUNT * 3);

    function initParticlePositions() {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        particlePositions[i * 3]     = (Math.random() - 0.5) * (TANK.xMax - TANK.xMin);
        particlePositions[i * 3 + 1] = (Math.random() - 0.5) * (TANK.yMax - TANK.yMin);
        particlePositions[i * 3 + 2] = (Math.random() - 0.5) * (TANK.zMax - TANK.zMin);
      }
    }
    initParticlePositions();

    const particleGeo = new THREE.BufferGeometry();
    particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    const particleMat = new THREE.PointsMaterial({
      color: 0xccddff,
      size: 0.08,
      transparent: true,
      opacity: 0.5,
      sizeAttenuation: true,
    });
    const particlePoints = new THREE.Points(particleGeo, particleMat);
    scene.add(particlePoints);

    function updateParticles(dt) {
      const pos = particleGeo.attributes.position.array;
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        pos[i * 3 + 1] += dt * 0.4; // drift up
        pos[i * 3]     += (Math.sin(i * 1.7 + performance.now() * 0.001) * 0.002); // gentle sway

        // Wrap at top
        if (pos[i * 3 + 1] > TANK.yMax) {
          pos[i * 3 + 1] = TANK.yMin;
          pos[i * 3]     = (Math.random() - 0.5) * (TANK.xMax - TANK.xMin);
          pos[i * 3 + 2] = (Math.random() - 0.5) * (TANK.zMax - TANK.zMin);
        }
      }
      particleGeo.attributes.position.needsUpdate = true;
    }

    // --- Project 3D to screen ---
    const _v = new THREE.Vector3();
    function projectToScreen(position) {
      _v.copy(position);
      _v.project(camera);
      return {
        x: ( _v.x *  0.5 + 0.5) * window.innerWidth,
        y: (-_v.y *  0.5 + 0.5) * window.innerHeight,
      };
    }

    // --- Update turtle movement ---
    function updateTurtleMovement(entry, dt, time) {
      const s = entry.state;
      const g = entry.group;

      // Move
      g.position.x += s.vx * dt;
      g.position.y += s.vy * dt;
      g.position.z += s.vz * dt;

      // Vertical bob
      g.position.y += Math.sin(time * 1.5 + s.phase) * s.amplitude;

      // Boundary bounce
      if (g.position.x < TANK.xMin) { g.position.x = TANK.xMin; s.vx = Math.abs(s.vx); }
      if (g.position.x > TANK.xMax) { g.position.x = TANK.xMax; s.vx = -Math.abs(s.vx); }
      if (g.position.y < TANK.yMin) { g.position.y = TANK.yMin; s.vy = Math.abs(s.vy); }
      if (g.position.y > TANK.yMax) { g.position.y = TANK.yMax; s.vy = -Math.abs(s.vy); }
      if (g.position.z < TANK.zMin) { g.position.z = TANK.zMin; s.vz = Math.abs(s.vz); }
      if (g.position.z > TANK.zMax) { g.position.z = TANK.zMax; s.vz = -Math.abs(s.vz); }

      // Rotation: Y heading from velocity, clamped to ±45°
      const targetY = Math.atan2(s.vx, s.vz);
      const clampedY = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, targetY));
      s.targetRotY = clampedY;
      s.currentRotY += (s.targetRotY - s.currentRotY) * Math.min(1, dt * 3);

      // X wobble for swimming motion (±10° around base tilt)
      const wobble = Math.sin(time * 2 + s.phase) * 0.17; // ~10 degrees

      g.rotation.x = s.baseRotX + wobble;
      g.rotation.y = s.currentRotY;

      // Flipper animation
      const children = g.children;
      for (const child of children) {
        if (child.name === 'fl_front_left') {
          child.rotation.z = Math.sin(time * s.flipperFreq) * 0.35; // ~20°
        } else if (child.name === 'fl_front_right') {
          child.rotation.z = Math.sin(time * s.flipperFreq + Math.PI) * 0.35;
        } else if (child.name === 'fl_back_left') {
          child.rotation.z = Math.sin(time * s.flipperFreq + 1.0) * 0.26; // ~15°
        } else if (child.name === 'fl_back_right') {
          child.rotation.z = Math.sin(time * s.flipperFreq + 1.0 + Math.PI) * 0.26;
        }
      }

      // Name label fade
      if (s.namePhase === 'fadein') {
        s.nameOpacity = Math.min(1, s.nameOpacity + dt);
        if (s.nameOpacity >= 1) {
          s.namePhase = 'visible';
          s.nameTimer = 0;
        }
      } else if (s.namePhase === 'visible') {
        s.nameTimer += dt;
        if (s.nameTimer >= 30) {
          s.namePhase = 'fadeout';
        }
      } else if (s.namePhase === 'fadeout') {
        s.nameOpacity = Math.max(0, s.nameOpacity - dt);
        if (s.nameOpacity <= 0) {
          s.namePhase = 'done';
        }
      }
    }

    // --- Update label positions ---
    function updateLabels() {
      for (const entry of turtleMap.values()) {
        const s = entry.state;
        const labelDiv = entry.labelDiv;

        if (s.nameOpacity > 0 && s.name) {
          const screen = projectToScreen(entry.group.position);
          labelDiv.style.left = screen.x + 'px';
          labelDiv.style.top = (screen.y - 30) + 'px';
          labelDiv.style.opacity = String(s.nameOpacity);
        } else {
          labelDiv.style.opacity = '0';
        }
      }
    }

    // --- Update title label tracking hero ---
    function updateTitle() {
      const heroEntry = turtleMap.get('hero');
      if (!heroEntry) {
        titleLabel.style.opacity = '0';
        return;
      }

      titleLabel.style.opacity = String(titleOpacity);

      const screen = projectToScreen(heroEntry.group.position);
      const titleY = Math.max(40, screen.y - 60);
      titleLabel.style.left = screen.x + 'px';
      titleLabel.style.top = titleY + 'px';

      // Responsive font size
      const fontSize = Math.min(48, window.innerWidth / 12);
      titleLabel.style.fontSize = fontSize + 'px';
    }

    // --- Polling ---
    async function pollTurtles() {
      try {
        const knownIds = Array.from(turtleMap.keys()).join(',');
        const url = `/api/turtles?eventCode=${encodeURIComponent(eventCode)}&knownIds=${encodeURIComponent(knownIds)}`;
        const res = await fetch(url);
        if (!res.ok) return;
        const data = await res.json();

        const serverIds = new Set();
        for (const st of data.turtles) {
          serverIds.add(st.id);

          if (turtleMap.has(st.id)) {
            // Existing: update name only
            const entry = turtleMap.get(st.id);
            entry.state.name = st.name;
            entry.labelDiv.textContent = st.name || '';
          } else {
            // New turtle
            const entry = await createTurtle3D(st);
            turtleMap.set(st.id, entry);
          }
        }

        // Remove turtles no longer on server
        for (const [id, entry] of turtleMap) {
          if (!serverIds.has(id)) {
            scene.remove(entry.group);
            entry.labelDiv.remove();
            // Dispose materials
            if (entry.shellMaterial) {
              if (entry.shellMaterial.map) entry.shellMaterial.map.dispose();
              entry.shellMaterial.dispose();
            }
            turtleMap.delete(id);
          }
        }
      } catch (e) {
        // Silent fail, retry next poll
      }
    }

    function startPolling() {
      pollTurtles();
      pollTimer = setInterval(pollTurtles, 3000);
    }

    // --- Animation Loop ---
    let lastFrame = performance.now();

    function animate(now) {
      if (!aquariumRunning) return;
      requestAnimationFrame(animate);

      const dt = Math.min((now - lastFrame) / 1000, 0.1);
      lastFrame = now;
      const time = (now / 1000) - startTime;

      // Fade in title
      if (titleOpacity < 1) {
        titleOpacity = Math.min(1, titleOpacity + dt * 0.5);
      }

      // Update turtles
      for (const entry of turtleMap.values()) {
        updateTurtleMovement(entry, dt, time);
      }

      // Update particles
      updateParticles(dt);

      // Update HTML labels
      updateLabels();
      updateTitle();

      // Render
      renderer.render(scene, camera);
    }

    // --- Code Entry ---
    async function validateCode(code) {
      try {
        const res = await fetch(`/api/turtles?eventCode=${encodeURIComponent(code)}&knownIds=`);
        return res.status;
      } catch {
        return 0;
      }
    }

    async function handleCodeSubmit() {
      const code = codeInput.value.trim();
      if (!code) return;

      codeError.textContent = '';
      codeSubmit.disabled = true;
      codeSubmit.textContent = 'Checking...';

      const status = await validateCode(code);

      if (status === 200) {
        eventCode = code;
        localStorage.setItem('turtleCode', code);
        overlay.classList.add('hidden');
        startAquarium();
      } else if (status === 429) {
        codeError.textContent = 'Too many attempts. Wait a moment.';
      } else if (status === 403) {
        codeError.textContent = 'Wrong code. Try again!';
      } else {
        codeError.textContent = 'Connection error. Try again.';
      }

      codeSubmit.disabled = false;
      codeSubmit.textContent = 'Enter';
    }

    codeSubmit.addEventListener('click', handleCodeSubmit);
    codeInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') handleCodeSubmit();
    });

    function startAquarium() {
      aquariumRunning = true;
      startTime = performance.now() / 1000;
      lastFrame = performance.now();
      startPolling();
      requestAnimationFrame(animate);
    }

    // --- Init: check for stored code ---
    (async () => {
      const stored = localStorage.getItem('turtleCode');
      if (stored) {
        const status = await validateCode(stored);
        if (status === 200) {
          eventCode = stored;
          overlay.classList.add('hidden');
          startAquarium();
          return;
        }
      }
      codeInput.focus();
    })();
  </script>
</body>
</html>
